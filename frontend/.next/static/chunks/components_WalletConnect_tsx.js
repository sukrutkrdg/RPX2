"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_WalletConnect_tsx"],{

/***/ "./components/WalletConnect.tsx":
/*!**************************************!*\
  !*** ./components/WalletConnect.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletConnect: function() { return /* binding */ WalletConnect; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wagmi */ \"../node_modules/wagmi/dist/esm/exports/index.js\");\n/* harmony import */ var wagmi_connectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wagmi/connectors */ \"../node_modules/wagmi/dist/esm/exports/connectors.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n// frontend/components/WalletConnect.tsx\n\nvar _s = $RefreshSig$();\n\n\n\n// Uygulamanın hedeflediği zincir ID'si (örn: Base)\nconst TARGET_CHAIN_ID = 8453; // Base Mainnet ID'si\nconst WalletConnect = ()=>{\n    _s();\n    // Wagmi hook'ları ile cüzdan durumunu al\n    const { address, isConnected, chainId } = (0,wagmi__WEBPACK_IMPORTED_MODULE_2__.useAccount)();\n    const { connect } = (0,wagmi__WEBPACK_IMPORTED_MODULE_2__.useConnect)();\n    const { disconnect } = (0,wagmi__WEBPACK_IMPORTED_MODULE_2__.useDisconnect)();\n    // Bağlanma butonu işlevi\n    const handleConnect = ()=>{\n        // Sadece MetaMask/Injected bir bağlayıcı ile bağlanmaya çalış\n        connect({\n            connector: (0,wagmi_connectors__WEBPACK_IMPORTED_MODULE_3__.injected)({\n                target: {\n                    id: TARGET_CHAIN_ID\n                }\n            })\n        });\n    };\n    // Hedef zincir kontrolü\n    const isCorrectChain = chainId === TARGET_CHAIN_ID;\n    // Adresin kısa gösterimi\n    const shortAddress = address ? \"\".concat(address.slice(0, 6), \"...\").concat(address.slice(-4)) : \"\";\n    if (isConnected) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center space-x-4 p-3 border rounded-lg bg-green-50\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"font-semibold text-green-700\",\n                    children: [\n                        \"\\uD83D\\uDFE2 Bağlı: \",\n                        shortAddress\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\sukru.kucuk\\\\Desktop\\\\REP-X\\\\frontend\\\\components\\\\WalletConnect.tsx\",\n                    lineNumber: 34,\n                    columnNumber: 9\n                }, undefined),\n                !isCorrectChain && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"text-red-600 font-bold\",\n                    children: \"⚠️ Yanlış Ağ! L\\xfctfen Base Ağına Ge\\xe7in.\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sukru.kucuk\\\\Desktop\\\\REP-X\\\\frontend\\\\components\\\\WalletConnect.tsx\",\n                    lineNumber: 39,\n                    columnNumber: 13\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: ()=>disconnect(),\n                    className: \"bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded text-sm\",\n                    children: \"Ayır\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\sukru.kucuk\\\\Desktop\\\\REP-X\\\\frontend\\\\components\\\\WalletConnect.tsx\",\n                    lineNumber: 44,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\sukru.kucuk\\\\Desktop\\\\REP-X\\\\frontend\\\\components\\\\WalletConnect.tsx\",\n            lineNumber: 33,\n            columnNumber: 7\n        }, undefined);\n    }\n    // Bağlı değilse, Bağlan butonu\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        onClick: handleConnect,\n        className: \"bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg\",\n        children: \"Yeni C\\xfczdanı Bağla (Yeni G\\xfcvenli C\\xfczdanınız)\"\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\sukru.kucuk\\\\Desktop\\\\REP-X\\\\frontend\\\\components\\\\WalletConnect.tsx\",\n        lineNumber: 56,\n        columnNumber: 5\n    }, undefined);\n}; // Bu dosyanın dışarıdan düzgün çalışması için ana uygulama yapısı kurulmalıdır (index.tsx ve _app.tsx)\n_s(WalletConnect, \"nXDcTtE5ME0WKOmwglvyS2sOCEI=\", false, function() {\n    return [\n        wagmi__WEBPACK_IMPORTED_MODULE_2__.useAccount,\n        wagmi__WEBPACK_IMPORTED_MODULE_2__.useConnect,\n        wagmi__WEBPACK_IMPORTED_MODULE_2__.useDisconnect\n    ];\n});\n_c = WalletConnect;\nvar _c;\n$RefreshReg$(_c, \"WalletConnect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1dhbGxldENvbm5lY3QudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx3Q0FBd0M7OztBQUVzQjtBQUVsQjtBQUNsQjtBQUUxQixtREFBbUQ7QUFDbkQsTUFBTUssa0JBQWtCLE1BQU0scUJBQXFCO0FBRTVDLE1BQU1DLGdCQUFnQjs7SUFDM0IseUNBQXlDO0lBQ3pDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUVDLE9BQU8sRUFBRSxHQUFHVCxpREFBVUE7SUFDcEQsTUFBTSxFQUFFVSxPQUFPLEVBQUUsR0FBR1QsaURBQVVBO0lBQzlCLE1BQU0sRUFBRVUsVUFBVSxFQUFFLEdBQUdULG9EQUFhQTtJQUVwQyx5QkFBeUI7SUFDekIsTUFBTVUsZ0JBQWdCO1FBQ3BCLDhEQUE4RDtRQUM5REYsUUFBUTtZQUFFRyxXQUFXViwwREFBUUEsQ0FBQztnQkFBRVcsUUFBUTtvQkFBRUMsSUFBSVY7Z0JBQWdCO1lBQUU7UUFBRztJQUNyRTtJQUVBLHdCQUF3QjtJQUN4QixNQUFNVyxpQkFBaUJQLFlBQVlKO0lBRW5DLHlCQUF5QjtJQUN6QixNQUFNWSxlQUFlVixVQUNqQixHQUE0QkEsT0FBekJBLFFBQVFXLEtBQUssQ0FBQyxHQUFHLElBQUcsT0FBdUIsT0FBbEJYLFFBQVFXLEtBQUssQ0FBQyxDQUFDLE1BQzNDO0lBRUosSUFBSVYsYUFBYTtRQUNmLHFCQUNFLDhEQUFDVztZQUFJQyxXQUFVOzs4QkFDYiw4REFBQ0M7b0JBQUtELFdBQVU7O3dCQUErQjt3QkFDbENIOzs7Ozs7O2dCQUdaLENBQUNELGdDQUNFLDhEQUFDSztvQkFBS0QsV0FBVTs4QkFBeUI7Ozs7Ozs4QkFLN0MsOERBQUNFO29CQUNDQyxTQUFTLElBQU1aO29CQUNmUyxXQUFVOzhCQUNYOzs7Ozs7Ozs7Ozs7SUFLUDtJQUVBLCtCQUErQjtJQUMvQixxQkFDRSw4REFBQ0U7UUFDQ0MsU0FBU1g7UUFDVFEsV0FBVTtrQkFDWDs7Ozs7O0FBSUwsRUFBRSxDQUVGLHVHQUF1RztHQXREMUZkOztRQUUrQk4sNkNBQVVBO1FBQ2hDQyw2Q0FBVUE7UUFDUEMsZ0RBQWFBOzs7S0FKekJJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvV2FsbGV0Q29ubmVjdC50c3g/OWJlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmcm9udGVuZC9jb21wb25lbnRzL1dhbGxldENvbm5lY3QudHN4XHJcblxyXG5pbXBvcnQgeyB1c2VBY2NvdW50LCB1c2VDb25uZWN0LCB1c2VEaXNjb25uZWN0IH0gZnJvbSAnd2FnbWknO1xyXG5pbXBvcnQgeyBtYWlubmV0IH0gZnJvbSAnd2FnbWkvY2hhaW5zJzsgLy8gVGVtZWwgRVZNIHppbmNpcmluaSAoQmFzZSwgT3B0aW1pc20gdmIuKSB0ZW1zaWwgZWRlclxyXG5pbXBvcnQgeyBpbmplY3RlZCB9IGZyb20gJ3dhZ21pL2Nvbm5lY3RvcnMnO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuLy8gVXlndWxhbWFuxLFuIGhlZGVmbGVkacSfaSB6aW5jaXIgSUQnc2kgKMO2cm46IEJhc2UpXHJcbmNvbnN0IFRBUkdFVF9DSEFJTl9JRCA9IDg0NTM7IC8vIEJhc2UgTWFpbm5ldCBJRCdzaVxyXG5cclxuZXhwb3J0IGNvbnN0IFdhbGxldENvbm5lY3QgPSAoKSA9PiB7XHJcbiAgLy8gV2FnbWkgaG9vaydsYXLEsSBpbGUgY8O8emRhbiBkdXJ1bXVudSBhbFxyXG4gIGNvbnN0IHsgYWRkcmVzcywgaXNDb25uZWN0ZWQsIGNoYWluSWQgfSA9IHVzZUFjY291bnQoKTtcclxuICBjb25zdCB7IGNvbm5lY3QgfSA9IHVzZUNvbm5lY3QoKTtcclxuICBjb25zdCB7IGRpc2Nvbm5lY3QgfSA9IHVzZURpc2Nvbm5lY3QoKTtcclxuXHJcbiAgLy8gQmHEn2xhbm1hIGJ1dG9udSBpxZ9sZXZpXHJcbiAgY29uc3QgaGFuZGxlQ29ubmVjdCA9ICgpID0+IHtcclxuICAgIC8vIFNhZGVjZSBNZXRhTWFzay9JbmplY3RlZCBiaXIgYmHEn2xhecSxY8SxIGlsZSBiYcSfbGFubWF5YSDDp2FsxLHFn1xyXG4gICAgY29ubmVjdCh7IGNvbm5lY3RvcjogaW5qZWN0ZWQoeyB0YXJnZXQ6IHsgaWQ6IFRBUkdFVF9DSEFJTl9JRCB9IH0pIH0pO1xyXG4gIH07XHJcbiAgXHJcbiAgLy8gSGVkZWYgemluY2lyIGtvbnRyb2zDvFxyXG4gIGNvbnN0IGlzQ29ycmVjdENoYWluID0gY2hhaW5JZCA9PT0gVEFSR0VUX0NIQUlOX0lEO1xyXG4gIFxyXG4gIC8vIEFkcmVzaW4ga8Sxc2EgZ8O2c3RlcmltaVxyXG4gIGNvbnN0IHNob3J0QWRkcmVzcyA9IGFkZHJlc3MgXHJcbiAgICA/IGAke2FkZHJlc3Muc2xpY2UoMCwgNil9Li4uJHthZGRyZXNzLnNsaWNlKC00KX1gXHJcbiAgICA6ICcnO1xyXG5cclxuICBpZiAoaXNDb25uZWN0ZWQpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC00IHAtMyBib3JkZXIgcm91bmRlZC1sZyBiZy1ncmVlbi01MFwiPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgdGV4dC1ncmVlbi03MDBcIj5cclxuICAgICAgICAgIPCfn6IgQmHEn2zEsToge3Nob3J0QWRkcmVzc31cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgXHJcbiAgICAgICAgeyFpc0NvcnJlY3RDaGFpbiAmJiAoXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtcmVkLTYwMCBmb250LWJvbGRcIj5cclxuICAgICAgICAgICAgICAgIOKaoO+4jyBZYW5sxLHFnyBBxJ8hIEzDvHRmZW4gQmFzZSBBxJ/EsW5hIEdlw6dpbi5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIDxidXR0b24gXHJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBkaXNjb25uZWN0KCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJiZy1yZWQtNTAwIGhvdmVyOmJnLXJlZC03MDAgdGV4dC13aGl0ZSBmb250LWJvbGQgcHktMSBweC0zIHJvdW5kZWQgdGV4dC1zbVwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgQXnEsXJcclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gQmHEn2zEsSBkZcSfaWxzZSwgQmHEn2xhbiBidXRvbnVcclxuICByZXR1cm4gKFxyXG4gICAgPGJ1dHRvbiBcclxuICAgICAgb25DbGljaz17aGFuZGxlQ29ubmVjdH1cclxuICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS02MDAgaG92ZXI6YmctYmx1ZS03MDAgdGV4dC13aGl0ZSBmb250LWJvbGQgcHktMiBweC00IHJvdW5kZWQtbGcgc2hhZG93LWxnXCJcclxuICAgID5cclxuICAgICAgWWVuaSBDw7x6ZGFuxLEgQmHEn2xhIChZZW5pIEfDvHZlbmxpIEPDvHpkYW7EsW7EsXopXHJcbiAgICA8L2J1dHRvbj5cclxuICApO1xyXG59O1xyXG5cclxuLy8gQnUgZG9zeWFuxLFuIGTEscWfYXLEsWRhbiBkw7x6Z8O8biDDp2FsxLHFn21hc8SxIGnDp2luIGFuYSB1eWd1bGFtYSB5YXDEsXPEsSBrdXJ1bG1hbMSxZMSxciAoaW5kZXgudHN4IHZlIF9hcHAudHN4KSJdLCJuYW1lcyI6WyJ1c2VBY2NvdW50IiwidXNlQ29ubmVjdCIsInVzZURpc2Nvbm5lY3QiLCJpbmplY3RlZCIsIlJlYWN0IiwiVEFSR0VUX0NIQUlOX0lEIiwiV2FsbGV0Q29ubmVjdCIsImFkZHJlc3MiLCJpc0Nvbm5lY3RlZCIsImNoYWluSWQiLCJjb25uZWN0IiwiZGlzY29ubmVjdCIsImhhbmRsZUNvbm5lY3QiLCJjb25uZWN0b3IiLCJ0YXJnZXQiLCJpZCIsImlzQ29ycmVjdENoYWluIiwic2hvcnRBZGRyZXNzIiwic2xpY2UiLCJkaXYiLCJjbGFzc05hbWUiLCJzcGFuIiwiYnV0dG9uIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/WalletConnect.tsx\n"));

/***/ }),

/***/ "../node_modules/wagmi/dist/esm/exports/connectors.js":
/*!************************************************************!*\
  !*** ../node_modules/wagmi/dist/esm/exports/connectors.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wagmi_connectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/connectors */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/exports/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _wagmi_connectors__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _wagmi_connectors__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n////////////////////////////////////////////////////////////////////////////////\n// @wagmi/connectors\n////////////////////////////////////////////////////////////////////////////////\n// biome-ignore lint/performance/noBarrelFile: entrypoint module\n// biome-ignore lint/performance/noReExportAll: entrypoint module\n\n//# sourceMappingURL=connectors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL2Rpc3QvZXNtL2V4cG9ydHMvY29ubmVjdG9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy93YWdtaS9kaXN0L2VzbS9leHBvcnRzL2Nvbm5lY3RvcnMuanM/MTc5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQHdhZ21pL2Nvbm5lY3RvcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBiaW9tZS1pZ25vcmUgbGludC9wZXJmb3JtYW5jZS9ub0JhcnJlbEZpbGU6IGVudHJ5cG9pbnQgbW9kdWxlXG4vLyBiaW9tZS1pZ25vcmUgbGludC9wZXJmb3JtYW5jZS9ub1JlRXhwb3J0QWxsOiBlbnRyeXBvaW50IG1vZHVsZVxuZXhwb3J0ICogZnJvbSAnQHdhZ21pL2Nvbm5lY3RvcnMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdG9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/wagmi/dist/esm/exports/connectors.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@gemini-wallet/core/dist/index.js":
/*!****************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@gemini-wallet/core/dist/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Communicator: function() { return /* binding */ Communicator; },\n/* harmony export */   DEFAULT_CHAIN_ID: function() { return /* binding */ DEFAULT_CHAIN_ID; },\n/* harmony export */   GeminiSdkEvent: function() { return /* binding */ GeminiSdkEvent; },\n/* harmony export */   GeminiStorage: function() { return /* binding */ GeminiStorage; },\n/* harmony export */   GeminiWallet: function() { return /* binding */ GeminiWallet; },\n/* harmony export */   GeminiWalletProvider: function() { return /* binding */ GeminiWalletProvider; },\n/* harmony export */   POPUP_HEIGHT: function() { return /* binding */ POPUP_HEIGHT; },\n/* harmony export */   POPUP_WIDTH: function() { return /* binding */ POPUP_WIDTH; },\n/* harmony export */   PlatformType: function() { return /* binding */ PlatformType; },\n/* harmony export */   ProviderEventEmitter: function() { return /* binding */ ProviderEventEmitter; },\n/* harmony export */   SDK_BACKEND_URL: function() { return /* binding */ SDK_BACKEND_URL; },\n/* harmony export */   SDK_VERSION: function() { return /* binding */ SDK_VERSION; },\n/* harmony export */   STORAGE_ETH_ACCOUNTS_KEY: function() { return /* binding */ STORAGE_ETH_ACCOUNTS_KEY; },\n/* harmony export */   STORAGE_ETH_ACTIVE_CHAIN_KEY: function() { return /* binding */ STORAGE_ETH_ACTIVE_CHAIN_KEY; },\n/* harmony export */   STORAGE_PASSKEY_CREDENTIAL_KEY: function() { return /* binding */ STORAGE_PASSKEY_CREDENTIAL_KEY; },\n/* harmony export */   STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY: function() { return /* binding */ STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY; },\n/* harmony export */   STORAGE_SETTINGS_KEY: function() { return /* binding */ STORAGE_SETTINGS_KEY; },\n/* harmony export */   STORAGE_SMART_ACCOUNT_KEY: function() { return /* binding */ STORAGE_SMART_ACCOUNT_KEY; },\n/* harmony export */   STORAGE_WC_REQUESTS_KEY: function() { return /* binding */ STORAGE_WC_REQUESTS_KEY; },\n/* harmony export */   base64ToHex: function() { return /* binding */ base64ToHex; },\n/* harmony export */   bufferToBase64URLString: function() { return /* binding */ bufferToBase64URLString; },\n/* harmony export */   calculateV1Address: function() { return /* binding */ calculateV1Address; },\n/* harmony export */   calculateWalletAddress: function() { return /* binding */ calculateWalletAddress; },\n/* harmony export */   closePopup: function() { return /* binding */ closePopup; },\n/* harmony export */   convertSendValuesToBigInt: function() { return /* binding */ convertSendValuesToBigInt; },\n/* harmony export */   decodeBase64: function() { return /* binding */ decodeBase64; },\n/* harmony export */   encodeBase64: function() { return /* binding */ encodeBase64; },\n/* harmony export */   fetchRpcRequest: function() { return /* binding */ fetchRpcRequest; },\n/* harmony export */   generateAuthenticatorIdHash: function() { return /* binding */ generateAuthenticatorIdHash; },\n/* harmony export */   hexStringFromNumber: function() { return /* binding */ hexStringFromNumber; },\n/* harmony export */   isChainSupportedByGeminiSw: function() { return /* binding */ isChainSupportedByGeminiSw; },\n/* harmony export */   openPopup: function() { return /* binding */ openPopup; },\n/* harmony export */   reverseResolveEns: function() { return /* binding */ reverseResolveEns; },\n/* harmony export */   safeJsonStringify: function() { return /* binding */ safeJsonStringify; },\n/* harmony export */   utf8StringToBuffer: function() { return /* binding */ utf8StringToBuffer; },\n/* harmony export */   validateRpcRequestArgs: function() { return /* binding */ validateRpcRequestArgs; },\n/* harmony export */   validateWebAuthnKey: function() { return /* binding */ validateWebAuthnKey; }\n/* harmony export */ });\n/* harmony import */ var _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @metamask/rpc-errors */ \"../node_modules/@metamask/rpc-errors/dist/index.mjs\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem/chains */ \"../node_modules/viem/_esm/chains/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"../node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../node_modules/buffer/index.js\")[\"Buffer\"];\n// src/communicator.ts\n\n\n// src/constants.ts\n\n\n// package.json\nvar package_default = {\n  name: \"@gemini-wallet/core\",\n  version: \"0.3.1\",\n  description: \"Core SDK for Gemini Wallet integration with popup communication\",\n  main: \"./dist/index.cjs\",\n  types: \"./dist/index.d.ts\",\n  type: \"module\",\n  repository: {\n    type: \"git\",\n    url: \"git+https://github.com/gemini/gemini-wallet-core.git\"\n  },\n  homepage: \"https://keys.gemini.com\",\n  bugs: {\n    url: \"https://github.com/gemini/gemini-wallet-core/issues\"\n  },\n  license: \"MIT\",\n  author: \"Gemini\",\n  files: [\n    \"dist\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  exports: {\n    \".\": {\n      types: \"./dist/index.d.ts\",\n      import: \"./dist/index.js\",\n      require: \"./dist/index.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  scripts: {\n    build: \"dotenv -e .env.production -- tsup\",\n    dev: \"dotenv -e .env.local -- tsup --watch\",\n    typecheck: \"tsc --noEmit\",\n    lint: \"eslint ./src\",\n    \"lint:ci\": \"eslint --max-warnings 0 ./src\",\n    \"lint:fix\": \"eslint ./src --fix\",\n    test: \"bun test\"\n  },\n  dependencies: {\n    \"@metamask/rpc-errors\": \"7.0.2\",\n    eventemitter3: \"5.0.1\"\n  },\n  devDependencies: {\n    \"@eslint/eslintrc\": \"3.3.1\",\n    \"@eslint/js\": \"9.33.0\",\n    \"@next/eslint-plugin-next\": \"15.4.7\",\n    \"@types/node\": \"22.13.0\",\n    \"dotenv-cli\": \"10.0.0\",\n    \"esbuild-plugin-replace\": \"1.4.0\",\n    eslint: \"9.33.0\",\n    \"eslint-config-prettier\": \"10.1.8\",\n    \"eslint-config-turbo\": \"2.5.6\",\n    \"eslint-plugin-import\": \"2.32.0\",\n    \"eslint-plugin-jsx-a11y\": \"6.10.2\",\n    \"eslint-plugin-only-warn\": \"1.1.0\",\n    \"eslint-plugin-prettier\": \"5.5.4\",\n    \"eslint-plugin-react\": \"7.37.5\",\n    \"eslint-plugin-react-hooks\": \"5.2.0\",\n    \"eslint-plugin-simple-import-sort\": \"12.1.1\",\n    \"eslint-plugin-sort-keys-fix\": \"1.1.2\",\n    globals: \"16.3.0\",\n    prettier: \"3.6.2\",\n    tsup: \"8.4.0\",\n    typescript: \"5.5.3\",\n    \"typescript-eslint\": \"8.40.0\",\n    vitest: \"3.2.4\"\n  },\n  peerDependencies: {\n    viem: \">=2.0.0\"\n  },\n  keywords: [\n    \"gemini\",\n    \"wallet\",\n    \"sdk\",\n    \"ethereum\",\n    \"web3\",\n    \"crypto\"\n  ],\n  module: \"./dist/index.js\"\n};\n\n// src/constants.ts\nvar DEFAULT_BACKEND_URL = \"https://keys.gemini.com\";\nvar SDK_BACKEND_URL = typeof process !== \"undefined\" && \"undefined\" || DEFAULT_BACKEND_URL;\nvar ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nvar SDK_VERSION = package_default.version;\nvar DEFAULT_CHAIN_ID = 42161;\nvar MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137\n};\nvar TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111\n};\nvar SUPPORTED_CHAIN_IDS = [\n  ...Object.values(MAINNET_CHAIN_IDS),\n  ...Object.values(TESTNET_CHAIN_IDS)\n];\nfunction getDefaultRpcUrl(chainId) {\n  const chainMap = {\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.mainnet.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.mainnet.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.arbitrum.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.arbitrum.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.optimism.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.optimism.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.base.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.base.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.polygon.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.polygon.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.sepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.sepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.arbitrumSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.arbitrumSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.optimismSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.optimismSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.baseSepolia.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.baseSepolia.rpcUrls.default.http[0],\n    [viem_chains__WEBPACK_IMPORTED_MODULE_0__.polygonAmoy.id]: viem_chains__WEBPACK_IMPORTED_MODULE_0__.polygonAmoy.rpcUrls.default.http[0]\n  };\n  return chainMap[chainId];\n}\nvar POPUP_WIDTH = 420;\nvar POPUP_HEIGHT = 650;\n\n// src/types.ts\n\nvar GeminiSdkEvent = /* @__PURE__ */ ((GeminiSdkEvent2) => {\n  GeminiSdkEvent2[\"POPUP_LOADED\"] = \"POPUP_LOADED\";\n  GeminiSdkEvent2[\"POPUP_UNLOADED\"] = \"POPUP_UNLOADED\";\n  GeminiSdkEvent2[\"POPUP_APP_CONTEXT\"] = \"POPUP_APP_CONTEXT\";\n  GeminiSdkEvent2[\"SDK_CONNECT\"] = \"SDK_CONNECT\";\n  GeminiSdkEvent2[\"SDK_DISCONNECT\"] = \"SDK_DISCONNECT\";\n  GeminiSdkEvent2[\"SDK_SEND_TRANSACTION\"] = \"SDK_SEND_TRANSACTION\";\n  GeminiSdkEvent2[\"SDK_SIGN_DATA\"] = \"SDK_SIGN_DATA\";\n  GeminiSdkEvent2[\"SDK_SIGN_TYPED_DATA\"] = \"SDK_SIGN_TYPED_DATA\";\n  GeminiSdkEvent2[\"SDK_SWITCH_CHAIN\"] = \"SDK_SWITCH_CHAIN\";\n  GeminiSdkEvent2[\"SDK_OPEN_SETTINGS\"] = \"SDK_OPEN_SETTINGS\";\n  GeminiSdkEvent2[\"SDK_CURRENT_ACCOUNT\"] = \"SDK_CURRENT_ACCOUNT\";\n  return GeminiSdkEvent2;\n})(GeminiSdkEvent || {});\nvar PlatformType = {\n  REACT_NATIVE: \"REACT_NATIVE\",\n  WEB: \"WEB\"\n};\nvar ProviderEventEmitter = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n};\n\n// src/utils/base64.ts\nfunction encodeBase64(array) {\n  let base64;\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(array).toString(\"base64\");\n  } else {\n    base64 = btoa(\n      Array.from(array).map((b) => String.fromCharCode(b)).join(\"\")\n    );\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeBase64(base64url) {\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  } else {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\nfunction utf8StringToBuffer(value) {\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(value);\n  } else if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  } else {\n    const bytes = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n      bytes[i] = value.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction base64ToHex(base64) {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n// src/utils/calculateWalletAddress.ts\n\nvar SHARED_CONTRACT_ADDRESSES = {\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\",\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\",\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\"\n};\nvar V2_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x00000000029d9c8b864DD51d6bb0d99FB72D650b\",\n  FACTORY: \"0x000000000452377e1Bd9e72E939855ECb9363Cab\",\n  WEBAUTHN_VALIDATOR: \"0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69\"\n};\nvar V1_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\",\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\",\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\"\n};\nfunction processWalletAddressParams(params, contractAddresses) {\n  const { publicKey, credentialId, index = 0n } = params;\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\n      \"Invalid public key: must be 64-byte hex string (0x + 128 chars)\"\n    );\n  }\n  const pubKeyX = `0x${publicKey.slice(2, 66)}`;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}`;\n  const webAuthnData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY)\n  };\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\n      \"Invalid WebAuthn key: coordinates are not on secp256r1 curve\"\n    );\n  }\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    contractAddresses,\n    index,\n    webAuthnData\n  });\n}\nfunction calculateWalletAddress(params) {\n  return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);\n}\nfunction calculateV1Address(params) {\n  return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);\n}\nfunction generateAuthenticatorIdHash(credentialId) {\n  const padding = \"=\".repeat((4 - credentialId.length % 4) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return (0,viem__WEBPACK_IMPORTED_MODULE_2__.keccak256)(bytes);\n}\nfunction validateWebAuthnKey(webAuthnData) {\n  const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n  const { pubKeyX, pubKeyY } = webAuthnData;\n  if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {\n    return false;\n  }\n  const ySquared = pubKeyY * pubKeyY % SECP256R1_P;\n  const xCubed = pubKeyX * pubKeyX * pubKeyX % SECP256R1_P;\n  const threeX = 3n * pubKeyX % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n  return ySquared === rightSide;\n}\nfunction calculateAddressInternal(params) {\n  const { webAuthnData, authenticatorIdHash, index, contractAddresses } = params;\n  const factoryAddress = contractAddresses.FACTORY;\n  const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;\n  const attester = contractAddresses.ATTESTER;\n  const bootstrapper = contractAddresses.BOOTSTRAPPER;\n  const registry = contractAddresses.REGISTRY;\n  const salt = (0,viem__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\n    (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodePacked)(\n      [\"uint256\", \"uint256\", \"bytes32\", \"uint256\"],\n      [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index]\n    )\n  );\n  const validatorInitData = (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodeAbiParameters)(\n    [\n      {\n        components: [\n          { name: \"pubKeyX\", type: \"uint256\" },\n          { name: \"pubKeyY\", type: \"uint256\" }\n        ],\n        type: \"tuple\"\n      },\n      { type: \"bytes32\" }\n    ],\n    [webAuthnData, authenticatorIdHash]\n  );\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n\n  };\n  const bootstrapCall = (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodeFunctionData)({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" }\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\"\n          }\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\"\n      }\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\"\n  });\n  const initData = (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodeAbiParameters)(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [bootstrapper, bootstrapCall]\n  );\n  return predictProxyAddress(\n    accountImplementation,\n    salt,\n    initData,\n    factoryAddress\n  );\n}\nfunction predictProxyAddress(implementation, salt, initData, deployer) {\n  const initializeCall = (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodeFunctionData)({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\"\n      }\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\"\n  });\n  const constructorArgs = (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodeAbiParameters)(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [implementation, initializeCall]\n  );\n  const nexusProxyCreationCode = \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\";\n  const initCodeHash = (0,viem__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\n    (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodePacked)([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs])\n  );\n  return (0,viem__WEBPACK_IMPORTED_MODULE_2__.getCreate2Address)({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt\n  });\n}\n\n// src/utils/ens.ts\nasync function reverseResolveEns(address) {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n    if (!response.ok) {\n      throw new Error(\n        `ENS API request failed: ${response.status} ${response.statusText}`\n      );\n    }\n    const data = await response.json();\n    return {\n      address: data.address,\n      name: data.name || null\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null\n    };\n  }\n}\n\n// src/utils/popup.ts\n\nvar POPUP_WIDTH2 = 420;\nvar POPUP_HEIGHT2 = 650;\nvar openPopup = (url) => {\n  const left = (window.innerWidth - POPUP_WIDTH2) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT2) / 2 + window.screenY;\n  const popupId = `wallet_${window?.crypto?.randomUUID()}`;\n  const popup = window.open(\n    url,\n    popupId,\n    `width=${POPUP_WIDTH2}, height=${POPUP_HEIGHT2}, left=${left}, top=${top}`\n  );\n  popup?.focus();\n  if (!popup) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.internal(\"Pop up window failed to open\");\n  }\n  return popup;\n};\nvar closePopup = (popup) => {\n  if (popup && !popup.closed) {\n    popup.opener?.focus();\n    popup.close();\n  }\n};\n\n// src/utils/strings.ts\nvar hexStringFromNumber = (num) => {\n  return `0x${BigInt(num).toString(16)}`;\n};\nvar safeJsonStringify = (obj) => JSON.stringify(\n  obj,\n  (_, value) => typeof value === \"bigint\" ? value.toString() + \"n\" : value,\n  2\n);\n\n// src/communicator.ts\nvar Communicator = class {\n  constructor({ appMetadata, onDisconnectCallback }) {\n    this.popup = null;\n    this.listeners = /* @__PURE__ */ new Map();\n    // posts a message to the popup window\n    this.postMessage = async (message) => {\n      const popup = await this.waitForPopupLoaded();\n      popup.postMessage(message, this.url.origin);\n    };\n    // posts a request to the popup window and waits for a response\n    this.postRequestAndWaitForResponse = async (request) => {\n      const responsePromise = this.onMessage(\n        ({ requestId }) => requestId === request.requestId\n      );\n      this.postMessage(request);\n      return await responsePromise;\n    };\n    // listens for messages from the popup window that match a given predicate\n    this.onMessage = (predicate) => {\n      return new Promise((resolve, reject) => {\n        const listener = (event) => {\n          if (event.origin !== this.url.origin) return;\n          const message = event.data;\n          if (predicate(message)) {\n            resolve(message);\n            window.removeEventListener(\"message\", listener);\n            this.listeners.delete(listener);\n          }\n        };\n        window.addEventListener(\"message\", listener);\n        this.listeners.set(listener, { reject });\n      });\n    };\n    // closes the popup, rejects all requests and clears event listeners\n    this.onRequestCancelled = () => {\n      closePopup(this.popup);\n      this.popup = null;\n      this.listeners.forEach(({ reject }, listener) => {\n        reject(_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.providerErrors.userRejectedRequest());\n        window.removeEventListener(\"message\", listener);\n      });\n      this.listeners.clear();\n    };\n    // waits for the popup window to fully load and then sends a version message\n    this.waitForPopupLoaded = () => {\n      if (this.popup && !this.popup.closed) {\n        this.popup.focus();\n        return Promise.resolve(this.popup);\n      }\n      this.popup = openPopup(this.url);\n      this.onMessage(\n        ({ event }) => event === \"POPUP_UNLOADED\" /* POPUP_UNLOADED */\n      ).then(this.onRequestCancelled).catch(() => {\n      });\n      this.onMessage(\n        ({ event }) => event === \"SDK_DISCONNECT\" /* SDK_DISCONNECT */\n      ).then(() => {\n        this.onDisconnectCallback?.();\n        this.onRequestCancelled();\n      }).catch(() => {\n      });\n      return this.onMessage(\n        ({ event }) => event === \"POPUP_LOADED\" /* POPUP_LOADED */\n      ).then((message) => {\n        this.postMessage({\n          chainId: DEFAULT_CHAIN_ID,\n          data: {\n            appMetadata: this.appMetadata,\n            origin: window.location.origin,\n            sdkVersion: SDK_VERSION\n          },\n          event: \"POPUP_APP_CONTEXT\" /* POPUP_APP_CONTEXT */,\n          origin: window.location.origin,\n          requestId: message.requestId\n        });\n      }).then(() => {\n        if (!this.popup) throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.internal();\n        return this.popup;\n      });\n    };\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n};\n\n// src/provider/provider.ts\n\n\n// src/storage/storage.ts\nvar memoryStorage = {};\nvar GeminiStorage = class {\n  constructor({\n    scope = \"@gemini\",\n    module = \"wallet\"\n  } = {}) {\n    this.scope = scope;\n    this.module = module;\n  }\n  scopedKey(key) {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n  async storeObject(key, item) {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n  async loadObject(key, fallback) {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async setItem(key, value) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.setItem(scoped, value);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      memoryStorage[scoped] = value;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async getItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      return localStorage.getItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      return memoryStorage[scoped] || null;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async removeItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.removeItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      delete memoryStorage[scoped];\n    }\n  }\n  async removeItems(keys) {\n    await Promise.all(keys.map((key) => this.removeItem(key)));\n  }\n};\n\n// src/storage/storageInterface.ts\nvar STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nvar STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nvar STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nvar STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY = \"preserved-passkey-credentials\";\nvar STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nvar STORAGE_SETTINGS_KEY = \"settings\";\nvar STORAGE_WC_REQUESTS_KEY = \"wc-requests\";\n\n// src/wallets/wallet.ts\nfunction isChainSupportedByGeminiSw(chainId) {\n  return SUPPORTED_CHAIN_IDS.includes(\n    chainId\n  );\n}\nvar GeminiWallet = class {\n  constructor({\n    appMetadata,\n    chain,\n    onDisconnectCallback,\n    storage\n  }) {\n    this.accounts = [];\n    this.chain = { id: DEFAULT_CHAIN_ID };\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback\n    });\n    this.storage = storage || new GeminiStorage();\n    const fallbackChainId = chain?.id ?? DEFAULT_CHAIN_ID;\n    const fallbackRpcUrl = chain?.rpcUrl ?? getDefaultRpcUrl(fallbackChainId);\n    const defaultChain = {\n      id: fallbackChainId,\n      rpcUrl: fallbackRpcUrl\n    };\n    this.initPromise = this.initializeFromStorage(defaultChain);\n  }\n  async initializeFromStorage(defaultChain) {\n    const fallbackChain = {\n      ...defaultChain,\n      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)\n    };\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject(\n        STORAGE_ETH_ACTIVE_CHAIN_KEY,\n        fallbackChain\n      ),\n      this.storage.loadObject(\n        STORAGE_ETH_ACCOUNTS_KEY,\n        this.accounts\n      )\n    ]);\n    this.chain = {\n      ...storedChain,\n      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)\n    };\n    this.accounts = storedAccounts;\n  }\n  async ensureInitialized() {\n    await this.initPromise;\n  }\n  async connect() {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      event: \"SDK_CONNECT\" /* SDK_CONNECT */,\n      origin: window.location.origin\n    });\n    this.accounts = response.data.address ? [response.data.address] : [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n    return this.accounts;\n  }\n  async disconnect() {\n    await this.ensureInitialized();\n    this.accounts = [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n  }\n  async switchChain({ id }) {\n    await this.ensureInitialized();\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = {\n        id,\n        rpcUrl: getDefaultRpcUrl(id)\n      };\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);\n      return null;\n    }\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: id,\n      event: \"SDK_SWITCH_CHAIN\" /* SDK_SWITCH_CHAIN */,\n      origin: window.location.origin\n    });\n    return response.data.error ?? \"Unsupported chain.\";\n  }\n  async sendTransaction(txData) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: txData,\n      event: \"SDK_SEND_TRANSACTION\" /* SDK_SEND_TRANSACTION */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signData({\n    message\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: { message },\n      event: \"SDK_SIGN_DATA\" /* SDK_SIGN_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types\n      },\n      event: \"SDK_SIGN_TYPED_DATA\" /* SDK_SIGN_TYPED_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async openSettings() {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {},\n      event: \"SDK_OPEN_SETTINGS\" /* SDK_OPEN_SETTINGS */,\n      origin: window.location.origin\n    });\n  }\n  sendMessageToPopup(request) {\n    return this.communicator.postRequestAndWaitForResponse({\n      ...request,\n      requestId: window?.crypto?.randomUUID()\n    });\n  }\n};\n\n// src/provider/provider.utils.ts\n\n\nvar fetchRpcRequest = async (request, rpcUrl) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\"\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    mode: \"cors\"\n  });\n  const { result, error } = await res.json();\n  if (error) throw error;\n  return result;\n};\nfunction validateRpcRequestArgs(args) {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.invalidParams({\n      message: \"Expected a single, non-array, object argument.\"\n    });\n  }\n  const { method, params } = args;\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.invalidParams({\n      message: \"'args.method' must be a non-empty string.\"\n    });\n  }\n  if (params !== void 0 && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\"\n    });\n  }\n}\nfunction convertSendValuesToBigInt(tx) {\n  const FIELDS_TO_NORMALIZE = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n  const normalized = { ...tx };\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) continue;\n    const value = tx[field];\n    if (typeof value === \"bigint\") continue;\n    if ((0,viem__WEBPACK_IMPORTED_MODULE_2__.isHex)(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n  return normalized;\n}\n\n// src/provider/provider.ts\nvar GeminiWalletProvider = class extends ProviderEventEmitter {\n  constructor(providerConfig) {\n    super();\n    this.wallet = null;\n    this.config = providerConfig;\n    const userDisconnectCallback = providerConfig.onDisconnectCallback;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: () => {\n        userDisconnectCallback?.();\n        this.disconnect();\n      }\n    });\n  }\n  async request(args) {\n    try {\n      validateRpcRequestArgs(args);\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            if (!this.wallet) {\n              const userDisconnectCallback = this.config.onDisconnectCallback;\n              this.wallet = new GeminiWallet({\n                ...this.config,\n                onDisconnectCallback: () => {\n                  userDisconnectCallback?.();\n                  this.disconnect();\n                }\n              });\n            }\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            return DEFAULT_CHAIN_ID;\n          case \"eth_chainId\":\n            return hexStringFromNumber(DEFAULT_CHAIN_ID);\n          default: {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.providerErrors.unauthorized();\n          }\n        }\n      }\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params;\n          response = await this.wallet.signData({\n            account: requestParams[1],\n            message: requestParams[0]\n          });\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          const rawParams = args.params;\n          let chainId;\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (rawParams && typeof rawParams === \"object\" && \"id\" in rawParams && Number.isInteger(rawParams.id)) {\n            chainId = rawParams.id;\n          } else {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.invalidParams(\n              \"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\"\n            );\n          }\n          response = await this.wallet.switchChain({ id: chainId });\n          if (response) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.providerErrors.custom({ code: 4902, message: response });\n          }\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params;\n          const signedTypedDataParams = JSON.parse(\n            requestParams[1]\n          );\n          response = await this.wallet.signTypedData({\n            account: requestParams[0],\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types\n          });\n          if (response.error) {\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        // TODO: not yet implemented or unclear if we support\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_sendCalls\":\n        case \"wallet_getCallsStatus\":\n        case \"wallet_getCapabilities\":\n        case \"wallet_showCallsStatus\":\n        case \"wallet_grantPermissions\":\n          throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.methodNotSupported(\"Not yet implemented.\");\n        // not supported\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.methodNotSupported();\n        // call rpc directly for everything else\n        default:\n          if (!this.wallet.chain.rpcUrl)\n            throw _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.rpcErrors.internal(\n              `RPC URL missing for current chain (${this.wallet.chain.id})`\n            );\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n      return response;\n    } catch (error) {\n      const { code } = error;\n      if (code === _metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.errorCodes.provider.unauthorized) this.disconnect();\n      return Promise.reject((0,_metamask_rpc_errors__WEBPACK_IMPORTED_MODULE_3__.serializeError)(error));\n    }\n  }\n  // custom wallet function to open settings page\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n  async disconnect() {\n    if (this.wallet) {\n      const storage = this.config.storage || new GeminiStorage();\n      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    }\n    this.wallet = null;\n    this.config.onDisconnectCallback?.();\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n    await this.emit(\"accountsChanged\", []);\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9AZ2VtaW5pLXdhbGxldC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytFOztBQUUvRTtBQVlxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdEQUFPLE1BQU0sZ0RBQU87QUFDekIsS0FBSyxpREFBUSxNQUFNLGlEQUFRO0FBQzNCLEtBQUssaURBQVEsTUFBTSxpREFBUTtBQUMzQixLQUFLLDZDQUFJLE1BQU0sNkNBQUk7QUFDbkIsS0FBSyxnREFBTyxNQUFNLGdEQUFPO0FBQ3pCLEtBQUssZ0RBQU8sTUFBTSxnREFBTztBQUN6QixLQUFLLHdEQUFlLE1BQU0sd0RBQWU7QUFDekMsS0FBSyx3REFBZSxNQUFNLHdEQUFlO0FBQ3pDLEtBQUssb0RBQVcsTUFBTSxvREFBVztBQUNqQyxLQUFLLG9EQUFXLE1BQU0sb0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVEQUFZO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsMEJBQTBCLE1BQU07QUFDaEMsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLE1BQU07QUFDMUIsMEJBQTBCLE1BQU07QUFDaEMsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFPYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBLFNBQVMsK0NBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOERBQThEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0NBQVM7QUFDeEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hELFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25ELGdCQUFnQixzQ0FBc0M7QUFDdEQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLHlEQUFtQjtBQUN0QyxPQUFPLGlCQUFpQixJQUFJLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEIseURBQW1CO0FBQzdDLE9BQU8saUJBQWlCLElBQUksZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQVM7QUFDaEMsSUFBSSxrREFBWTtBQUNoQjtBQUNBLFNBQVMsdURBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxXQUFXLFFBQVE7QUFDbkU7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhLFdBQVcsY0FBYyxTQUFTLEtBQUssUUFBUSxJQUFJO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkRBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMsZUFBZSxnRUFBYztBQUM3QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLE9BQU87QUFDUDtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsK0JBQStCLDJEQUFVO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU04Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsR0FBRyxZQUFZLEdBQUcsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDK0Q7QUFDbEM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyREFBVTtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0EsVUFBVSwyREFBVTtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSwyREFBVTtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFrQiwyREFBVTtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFVO0FBQzVCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaLGtCQUFrQiwyREFBVTtBQUM1QixzREFBc0QscUJBQXFCLE9BQU8sWUFBWTtBQUM5RjtBQUNBO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQSxrQkFBa0IsZ0VBQWUsVUFBVSwrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrQkFBa0IsMkRBQVU7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBVTtBQUM1QixvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsT0FBTztBQUNyQixtQkFBbUIsNERBQVU7QUFDN0IsNEJBQTRCLG9FQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVDRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvd2FnbWkvbm9kZV9tb2R1bGVzL0BnZW1pbmktd2FsbGV0L2NvcmUvZGlzdC9pbmRleC5qcz84NDY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21tdW5pY2F0b3IudHNcbmltcG9ydCB7IHByb3ZpZGVyRXJyb3JzLCBycGNFcnJvcnMgYXMgcnBjRXJyb3JzMiB9IGZyb20gXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG5pbXBvcnQge1xuICBhcmJpdHJ1bSxcbiAgYXJiaXRydW1TZXBvbGlhLFxuICBiYXNlLFxuICBiYXNlU2Vwb2xpYSxcbiAgbWFpbm5ldCxcbiAgb3B0aW1pc20sXG4gIG9wdGltaXNtU2Vwb2xpYSxcbiAgcG9seWdvbixcbiAgcG9seWdvbkFtb3ksXG4gIHNlcG9saWFcbn0gZnJvbSBcInZpZW0vY2hhaW5zXCI7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHBhY2thZ2VfZGVmYXVsdCA9IHtcbiAgbmFtZTogXCJAZ2VtaW5pLXdhbGxldC9jb3JlXCIsXG4gIHZlcnNpb246IFwiMC4zLjFcIixcbiAgZGVzY3JpcHRpb246IFwiQ29yZSBTREsgZm9yIEdlbWluaSBXYWxsZXQgaW50ZWdyYXRpb24gd2l0aCBwb3B1cCBjb21tdW5pY2F0aW9uXCIsXG4gIG1haW46IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICB0eXBlczogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICB0eXBlOiBcIm1vZHVsZVwiLFxuICByZXBvc2l0b3J5OiB7XG4gICAgdHlwZTogXCJnaXRcIixcbiAgICB1cmw6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9nZW1pbmkvZ2VtaW5pLXdhbGxldC1jb3JlLmdpdFwiXG4gIH0sXG4gIGhvbWVwYWdlOiBcImh0dHBzOi8va2V5cy5nZW1pbmkuY29tXCIsXG4gIGJ1Z3M6IHtcbiAgICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL2dlbWluaS9nZW1pbmktd2FsbGV0LWNvcmUvaXNzdWVzXCJcbiAgfSxcbiAgbGljZW5zZTogXCJNSVRcIixcbiAgYXV0aG9yOiBcIkdlbWluaVwiLFxuICBmaWxlczogW1xuICAgIFwiZGlzdFwiLFxuICAgIFwic3JjXCIsXG4gICAgXCJSRUFETUUubWRcIixcbiAgICBcIkxJQ0VOU0VcIlxuICBdLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHR5cGVzOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICBpbXBvcnQ6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gICAgICByZXF1aXJlOiBcIi4vZGlzdC9pbmRleC5janNcIlxuICAgIH0sXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiBcIi4vcGFja2FnZS5qc29uXCJcbiAgfSxcbiAgc2NyaXB0czoge1xuICAgIGJ1aWxkOiBcImRvdGVudiAtZSAuZW52LnByb2R1Y3Rpb24gLS0gdHN1cFwiLFxuICAgIGRldjogXCJkb3RlbnYgLWUgLmVudi5sb2NhbCAtLSB0c3VwIC0td2F0Y2hcIixcbiAgICB0eXBlY2hlY2s6IFwidHNjIC0tbm9FbWl0XCIsXG4gICAgbGludDogXCJlc2xpbnQgLi9zcmNcIixcbiAgICBcImxpbnQ6Y2lcIjogXCJlc2xpbnQgLS1tYXgtd2FybmluZ3MgMCAuL3NyY1wiLFxuICAgIFwibGludDpmaXhcIjogXCJlc2xpbnQgLi9zcmMgLS1maXhcIixcbiAgICB0ZXN0OiBcImJ1biB0ZXN0XCJcbiAgfSxcbiAgZGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiOiBcIjcuMC4yXCIsXG4gICAgZXZlbnRlbWl0dGVyMzogXCI1LjAuMVwiXG4gIH0sXG4gIGRldkRlcGVuZGVuY2llczoge1xuICAgIFwiQGVzbGludC9lc2xpbnRyY1wiOiBcIjMuMy4xXCIsXG4gICAgXCJAZXNsaW50L2pzXCI6IFwiOS4zMy4wXCIsXG4gICAgXCJAbmV4dC9lc2xpbnQtcGx1Z2luLW5leHRcIjogXCIxNS40LjdcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiMjIuMTMuMFwiLFxuICAgIFwiZG90ZW52LWNsaVwiOiBcIjEwLjAuMFwiLFxuICAgIFwiZXNidWlsZC1wbHVnaW4tcmVwbGFjZVwiOiBcIjEuNC4wXCIsXG4gICAgZXNsaW50OiBcIjkuMzMuMFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1wcmV0dGllclwiOiBcIjEwLjEuOFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy10dXJib1wiOiBcIjIuNS42XCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOiBcIjIuMzIuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1qc3gtYTExeVwiOiBcIjYuMTAuMlwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1vbmx5LXdhcm5cIjogXCIxLjEuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcmV0dGllclwiOiBcIjUuNS40XCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwiNy4zNy41XCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXJlYWN0LWhvb2tzXCI6IFwiNS4yLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tc2ltcGxlLWltcG9ydC1zb3J0XCI6IFwiMTIuMS4xXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXNvcnQta2V5cy1maXhcIjogXCIxLjEuMlwiLFxuICAgIGdsb2JhbHM6IFwiMTYuMy4wXCIsXG4gICAgcHJldHRpZXI6IFwiMy42LjJcIixcbiAgICB0c3VwOiBcIjguNC4wXCIsXG4gICAgdHlwZXNjcmlwdDogXCI1LjUuM1wiLFxuICAgIFwidHlwZXNjcmlwdC1lc2xpbnRcIjogXCI4LjQwLjBcIixcbiAgICB2aXRlc3Q6IFwiMy4yLjRcIlxuICB9LFxuICBwZWVyRGVwZW5kZW5jaWVzOiB7XG4gICAgdmllbTogXCI+PTIuMC4wXCJcbiAgfSxcbiAga2V5d29yZHM6IFtcbiAgICBcImdlbWluaVwiLFxuICAgIFwid2FsbGV0XCIsXG4gICAgXCJzZGtcIixcbiAgICBcImV0aGVyZXVtXCIsXG4gICAgXCJ3ZWIzXCIsXG4gICAgXCJjcnlwdG9cIlxuICBdLFxuICBtb2R1bGU6IFwiLi9kaXN0L2luZGV4LmpzXCJcbn07XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBQ0tFTkRfVVJMID0gXCJodHRwczovL2tleXMuZ2VtaW5pLmNvbVwiO1xudmFyIFNES19CQUNLRU5EX1VSTCA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIFwidW5kZWZpbmVkXCIgfHwgREVGQVVMVF9CQUNLRU5EX1VSTDtcbnZhciBFTlNfQVBJX1VSTCA9IFwiaHR0cHM6Ly9ob3Jpem9uLWFwaS5nZW1pbmkuY29tL2FwaS9lbnNcIjtcbnZhciBTREtfVkVSU0lPTiA9IHBhY2thZ2VfZGVmYXVsdC52ZXJzaW9uO1xudmFyIERFRkFVTFRfQ0hBSU5fSUQgPSA0MjE2MTtcbnZhciBNQUlOTkVUX0NIQUlOX0lEUyA9IHtcbiAgQVJCSVRSVU1fT05FOiA0MjE2MSxcbiAgQkFTRTogODQ1MyxcbiAgRVRIRVJFVU06IDEsXG4gIE9QX01BSU5ORVQ6IDEwLFxuICBQT0xZR09OOiAxMzdcbn07XG52YXIgVEVTVE5FVF9DSEFJTl9JRFMgPSB7XG4gIEFSQklUUlVNX1NFUE9MSUE6IDQyMTYxNCxcbiAgQkFTRV9TRVBPTElBOiA4NDUzMixcbiAgT1BfU0VQT0xJQTogMTExNTU0MjAsXG4gIFBPTFlHT05fQU1PWTogODAwMDIsXG4gIFNFUE9MSUE6IDExMTU1MTExXG59O1xudmFyIFNVUFBPUlRFRF9DSEFJTl9JRFMgPSBbXG4gIC4uLk9iamVjdC52YWx1ZXMoTUFJTk5FVF9DSEFJTl9JRFMpLFxuICAuLi5PYmplY3QudmFsdWVzKFRFU1RORVRfQ0hBSU5fSURTKVxuXTtcbmZ1bmN0aW9uIGdldERlZmF1bHRScGNVcmwoY2hhaW5JZCkge1xuICBjb25zdCBjaGFpbk1hcCA9IHtcbiAgICBbbWFpbm5ldC5pZF06IG1haW5uZXQucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2FyYml0cnVtLmlkXTogYXJiaXRydW0ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW29wdGltaXNtLmlkXTogb3B0aW1pc20ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2Jhc2UuaWRdOiBiYXNlLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtwb2x5Z29uLmlkXTogcG9seWdvbi5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbc2Vwb2xpYS5pZF06IHNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgW2FyYml0cnVtU2Vwb2xpYS5pZF06IGFyYml0cnVtU2Vwb2xpYS5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXSxcbiAgICBbb3B0aW1pc21TZXBvbGlhLmlkXTogb3B0aW1pc21TZXBvbGlhLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtiYXNlU2Vwb2xpYS5pZF06IGJhc2VTZXBvbGlhLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdLFxuICAgIFtwb2x5Z29uQW1veS5pZF06IHBvbHlnb25BbW95LnJwY1VybHMuZGVmYXVsdC5odHRwWzBdXG4gIH07XG4gIHJldHVybiBjaGFpbk1hcFtjaGFpbklkXTtcbn1cbnZhciBQT1BVUF9XSURUSCA9IDQyMDtcbnZhciBQT1BVUF9IRUlHSFQgPSA2NTA7XG5cbi8vIHNyYy90eXBlcy50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbnZhciBHZW1pbmlTZGtFdmVudCA9IC8qIEBfX1BVUkVfXyAqLyAoKEdlbWluaVNka0V2ZW50MikgPT4ge1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9MT0FERURcIl0gPSBcIlBPUFVQX0xPQURFRFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJQT1BVUF9VTkxPQURFRFwiXSA9IFwiUE9QVVBfVU5MT0FERURcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiUE9QVVBfQVBQX0NPTlRFWFRcIl0gPSBcIlBPUFVQX0FQUF9DT05URVhUXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19DT05ORUNUXCJdID0gXCJTREtfQ09OTkVDVFwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfRElTQ09OTkVDVFwiXSA9IFwiU0RLX0RJU0NPTk5FQ1RcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NFTkRfVFJBTlNBQ1RJT05cIl0gPSBcIlNES19TRU5EX1RSQU5TQUNUSU9OXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19TSUdOX0RBVEFcIl0gPSBcIlNES19TSUdOX0RBVEFcIjtcbiAgR2VtaW5pU2RrRXZlbnQyW1wiU0RLX1NJR05fVFlQRURfREFUQVwiXSA9IFwiU0RLX1NJR05fVFlQRURfREFUQVwiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfU1dJVENIX0NIQUlOXCJdID0gXCJTREtfU1dJVENIX0NIQUlOXCI7XG4gIEdlbWluaVNka0V2ZW50MltcIlNES19PUEVOX1NFVFRJTkdTXCJdID0gXCJTREtfT1BFTl9TRVRUSU5HU1wiO1xuICBHZW1pbmlTZGtFdmVudDJbXCJTREtfQ1VSUkVOVF9BQ0NPVU5UXCJdID0gXCJTREtfQ1VSUkVOVF9BQ0NPVU5UXCI7XG4gIHJldHVybiBHZW1pbmlTZGtFdmVudDI7XG59KShHZW1pbmlTZGtFdmVudCB8fCB7fSk7XG52YXIgUGxhdGZvcm1UeXBlID0ge1xuICBSRUFDVF9OQVRJVkU6IFwiUkVBQ1RfTkFUSVZFXCIsXG4gIFdFQjogXCJXRUJcIlxufTtcbnZhciBQcm92aWRlckV2ZW50RW1pdHRlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbn07XG5cbi8vIHNyYy91dGlscy9iYXNlNjQudHNcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChhcnJheSkge1xuICBsZXQgYmFzZTY0O1xuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGFycmF5KS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlNjQgPSBidG9hKFxuICAgICAgQXJyYXkuZnJvbShhcnJheSkubWFwKChiKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKS5qb2luKFwiXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYmFzZTY0LnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChiYXNlNjR1cmwpIHtcbiAgbGV0IGJhc2U2NCA9IGJhc2U2NHVybC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgd2hpbGUgKGJhc2U2NC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgYmFzZTY0ICs9IFwiPVwiO1xuICB9XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIikpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKGJ1ZmZlcikge1xuICBjb25zdCBieXRlcyA9IGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBidWZmZXIgOiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4gZW5jb2RlQmFzZTY0KGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb0J1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh2YWx1ZSwgXCJ1dGY4XCIpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NFRvSGV4KGJhc2U2NCkge1xuICBjb25zdCBieXRlcyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xuICByZXR1cm4gQXJyYXkuZnJvbShieXRlcykubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG59XG5cbi8vIHNyYy91dGlscy9jYWxjdWxhdGVXYWxsZXRBZGRyZXNzLnRzXG5pbXBvcnQge1xuICBlbmNvZGVBYmlQYXJhbWV0ZXJzLFxuICBlbmNvZGVGdW5jdGlvbkRhdGEsXG4gIGVuY29kZVBhY2tlZCxcbiAgZ2V0Q3JlYXRlMkFkZHJlc3MsXG4gIGtlY2NhazI1NlxufSBmcm9tIFwidmllbVwiO1xudmFyIFNIQVJFRF9DT05UUkFDVF9BRERSRVNTRVMgPSB7XG4gIEFUVEVTVEVSOiBcIjB4MDAwNDc0MzkyYTljZDg2YTQ2ODczNTRmMUNlMjk2NEI1MmU5NzQ4NFwiLFxuICBCT09UU1RSQVBQRVI6IFwiMHgwMDAwMDAwMEQzMjU0NDUyYTkwOUU0ZWVENDc0NTVBZjdFMjdDMjg5XCIsXG4gIFJFR0lTVFJZOiBcIjB4MDAwMDAwMDAwMDY5RTJhMTg3QUVGRmI4NTJiRjNjQ2RDOTUxNTFCMlwiXG59O1xudmFyIFYyX0NPTlRSQUNUX0FERFJFU1NFUyA9IHtcbiAgLi4uU0hBUkVEX0NPTlRSQUNUX0FERFJFU1NFUyxcbiAgQUNDT1VOVF9JTVBMRU1FTlRBVElPTjogXCIweDAwMDAwMDAwMDI5ZDljOGI4NjRERDUxZDZiYjBkOTlGQjcyRDY1MGJcIixcbiAgRkFDVE9SWTogXCIweDAwMDAwMDAwMDQ1MjM3N2UxQmQ5ZTcyRTkzOTg1NUVDYjkzNjNDYWJcIixcbiAgV0VCQVVUSE5fVkFMSURBVE9SOiBcIjB4N2FiMTZGZjM1NEFjQjMyODQ1MkYxRDQ0NWIzRGRlZTlhOTFlOWU2OVwiXG59O1xudmFyIFYxX0NPTlRSQUNUX0FERFJFU1NFUyA9IHtcbiAgLi4uU0hBUkVEX0NPTlRSQUNUX0FERFJFU1NFUyxcbiAgQUNDT1VOVF9JTVBMRU1FTlRBVElPTjogXCIweDAwMDYwNTAxNjhERTI1NWE4NjcyQUNhRDQ4MjFlNzIxQ0JBNDQzMzdcIixcbiAgRkFDVE9SWTogXCIweDAwRTU4REY3MEZhQjk4M2EzMjRjNEMwNjhjODJkMjA0MDc1NzlGYUNcIixcbiAgV0VCQVVUSE5fVkFMSURBVE9SOiBcIjB4YkE0NWEyQkZiOERlM0QyNGNBOUQ3RjFCNTUxRTE0ZEZGNWQ2OTBGZFwiXG59O1xuZnVuY3Rpb24gcHJvY2Vzc1dhbGxldEFkZHJlc3NQYXJhbXMocGFyYW1zLCBjb250cmFjdEFkZHJlc3Nlcykge1xuICBjb25zdCB7IHB1YmxpY0tleSwgY3JlZGVudGlhbElkLCBpbmRleCA9IDBuIH0gPSBwYXJhbXM7XG4gIGlmICghcHVibGljS2V5LnN0YXJ0c1dpdGgoXCIweFwiKSB8fCBwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgcHVibGljIGtleTogbXVzdCBiZSA2NC1ieXRlIGhleCBzdHJpbmcgKDB4ICsgMTI4IGNoYXJzKVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBwdWJLZXlYID0gYDB4JHtwdWJsaWNLZXkuc2xpY2UoMiwgNjYpfWA7XG4gIGNvbnN0IHB1YktleVkgPSBgMHgke3B1YmxpY0tleS5zbGljZSg2NiwgMTMwKX1gO1xuICBjb25zdCB3ZWJBdXRobkRhdGEgPSB7XG4gICAgcHViS2V5WDogQmlnSW50KHB1YktleVgpLFxuICAgIHB1YktleVk6IEJpZ0ludChwdWJLZXlZKVxuICB9O1xuICBpZiAoIXZhbGlkYXRlV2ViQXV0aG5LZXkod2ViQXV0aG5EYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBXZWJBdXRobiBrZXk6IGNvb3JkaW5hdGVzIGFyZSBub3Qgb24gc2VjcDI1NnIxIGN1cnZlXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IGF1dGhlbnRpY2F0b3JJZEhhc2ggPSBnZW5lcmF0ZUF1dGhlbnRpY2F0b3JJZEhhc2goY3JlZGVudGlhbElkKTtcbiAgcmV0dXJuIGNhbGN1bGF0ZUFkZHJlc3NJbnRlcm5hbCh7XG4gICAgYXV0aGVudGljYXRvcklkSGFzaCxcbiAgICBjb250cmFjdEFkZHJlc3NlcyxcbiAgICBpbmRleCxcbiAgICB3ZWJBdXRobkRhdGFcbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVXYWxsZXRBZGRyZXNzKHBhcmFtcykge1xuICByZXR1cm4gcHJvY2Vzc1dhbGxldEFkZHJlc3NQYXJhbXMocGFyYW1zLCBWMl9DT05UUkFDVF9BRERSRVNTRVMpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVjFBZGRyZXNzKHBhcmFtcykge1xuICByZXR1cm4gcHJvY2Vzc1dhbGxldEFkZHJlc3NQYXJhbXMocGFyYW1zLCBWMV9DT05UUkFDVF9BRERSRVNTRVMpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVBdXRoZW50aWNhdG9ySWRIYXNoKGNyZWRlbnRpYWxJZCkge1xuICBjb25zdCBwYWRkaW5nID0gXCI9XCIucmVwZWF0KCg0IC0gY3JlZGVudGlhbElkLmxlbmd0aCAlIDQpICUgNCk7XG4gIGNvbnN0IGJhc2U2NCA9IGNyZWRlbnRpYWxJZC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSArIHBhZGRpbmc7XG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBrZWNjYWsyNTYoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVXZWJBdXRobktleSh3ZWJBdXRobkRhdGEpIHtcbiAgY29uc3QgU0VDUDI1NlIxX1AgPSAweGZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuO1xuICBjb25zdCBTRUNQMjU2UjFfQiA9IDB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0Ym47XG4gIGNvbnN0IHsgcHViS2V5WCwgcHViS2V5WSB9ID0gd2ViQXV0aG5EYXRhO1xuICBpZiAocHViS2V5WCA9PT0gMG4gfHwgcHViS2V5WSA9PT0gMG4gfHwgcHViS2V5WCA+PSBTRUNQMjU2UjFfUCB8fCBwdWJLZXlZID49IFNFQ1AyNTZSMV9QKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHlTcXVhcmVkID0gcHViS2V5WSAqIHB1YktleVkgJSBTRUNQMjU2UjFfUDtcbiAgY29uc3QgeEN1YmVkID0gcHViS2V5WCAqIHB1YktleVggKiBwdWJLZXlYICUgU0VDUDI1NlIxX1A7XG4gIGNvbnN0IHRocmVlWCA9IDNuICogcHViS2V5WCAlIFNFQ1AyNTZSMV9QO1xuICBjb25zdCByaWdodFNpZGUgPSAoeEN1YmVkICsgU0VDUDI1NlIxX1AgLSB0aHJlZVggKyBTRUNQMjU2UjFfQikgJSBTRUNQMjU2UjFfUDtcbiAgcmV0dXJuIHlTcXVhcmVkID09PSByaWdodFNpZGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVBZGRyZXNzSW50ZXJuYWwocGFyYW1zKSB7XG4gIGNvbnN0IHsgd2ViQXV0aG5EYXRhLCBhdXRoZW50aWNhdG9ySWRIYXNoLCBpbmRleCwgY29udHJhY3RBZGRyZXNzZXMgfSA9IHBhcmFtcztcbiAgY29uc3QgZmFjdG9yeUFkZHJlc3MgPSBjb250cmFjdEFkZHJlc3Nlcy5GQUNUT1JZO1xuICBjb25zdCBhY2NvdW50SW1wbGVtZW50YXRpb24gPSBjb250cmFjdEFkZHJlc3Nlcy5BQ0NPVU5UX0lNUExFTUVOVEFUSU9OO1xuICBjb25zdCB3ZWJBdXRoblZhbGlkYXRvciA9IGNvbnRyYWN0QWRkcmVzc2VzLldFQkFVVEhOX1ZBTElEQVRPUjtcbiAgY29uc3QgYXR0ZXN0ZXIgPSBjb250cmFjdEFkZHJlc3Nlcy5BVFRFU1RFUjtcbiAgY29uc3QgYm9vdHN0cmFwcGVyID0gY29udHJhY3RBZGRyZXNzZXMuQk9PVFNUUkFQUEVSO1xuICBjb25zdCByZWdpc3RyeSA9IGNvbnRyYWN0QWRkcmVzc2VzLlJFR0lTVFJZO1xuICBjb25zdCBzYWx0ID0ga2VjY2FrMjU2KFxuICAgIGVuY29kZVBhY2tlZChcbiAgICAgIFtcInVpbnQyNTZcIiwgXCJ1aW50MjU2XCIsIFwiYnl0ZXMzMlwiLCBcInVpbnQyNTZcIl0sXG4gICAgICBbd2ViQXV0aG5EYXRhLnB1YktleVgsIHdlYkF1dGhuRGF0YS5wdWJLZXlZLCBhdXRoZW50aWNhdG9ySWRIYXNoLCBpbmRleF1cbiAgICApXG4gICk7XG4gIGNvbnN0IHZhbGlkYXRvckluaXREYXRhID0gZW5jb2RlQWJpUGFyYW1ldGVycyhcbiAgICBbXG4gICAgICB7XG4gICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICB7IG5hbWU6IFwicHViS2V5WFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgIHsgbmFtZTogXCJwdWJLZXlZXCIsIHR5cGU6IFwidWludDI1NlwiIH1cbiAgICAgICAgXSxcbiAgICAgICAgdHlwZTogXCJ0dXBsZVwiXG4gICAgICB9LFxuICAgICAgeyB0eXBlOiBcImJ5dGVzMzJcIiB9XG4gICAgXSxcbiAgICBbd2ViQXV0aG5EYXRhLCBhdXRoZW50aWNhdG9ySWRIYXNoXVxuICApO1xuICBjb25zdCByZWdpc3RyeUNvbmZpZyA9IHtcbiAgICBhdHRlc3RlcnM6IFthdHRlc3Rlcl0sXG4gICAgcmVnaXN0cnksXG4gICAgdGhyZXNob2xkOiAxblxuICB9O1xuICBjb25zdCBib290c3RyYXBDYWxsID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICBhYmk6IFtcbiAgICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcInZhbGlkYXRvclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgIHsgbmFtZTogXCJ2YWxpZGF0b3JJbml0RGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJyZWdpc3RyeVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiYXR0ZXN0ZXJzXCIsIHR5cGU6IFwiYWRkcmVzc1tdXCIgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInRocmVzaG9sZFwiLCB0eXBlOiBcInVpbnQ4XCIgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG5hbWU6IFwicmVnaXN0cnlDb25maWdcIixcbiAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJpbml0TmV4dXNXaXRoU2luZ2xlVmFsaWRhdG9yXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIF0sXG4gICAgYXJnczogW3dlYkF1dGhuVmFsaWRhdG9yLCB2YWxpZGF0b3JJbml0RGF0YSwgcmVnaXN0cnlDb25maWddLFxuICAgIGZ1bmN0aW9uTmFtZTogXCJpbml0TmV4dXNXaXRoU2luZ2xlVmFsaWRhdG9yXCJcbiAgfSk7XG4gIGNvbnN0IGluaXREYXRhID0gZW5jb2RlQWJpUGFyYW1ldGVycyhcbiAgICBbeyB0eXBlOiBcImFkZHJlc3NcIiB9LCB7IHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICBbYm9vdHN0cmFwcGVyLCBib290c3RyYXBDYWxsXVxuICApO1xuICByZXR1cm4gcHJlZGljdFByb3h5QWRkcmVzcyhcbiAgICBhY2NvdW50SW1wbGVtZW50YXRpb24sXG4gICAgc2FsdCxcbiAgICBpbml0RGF0YSxcbiAgICBmYWN0b3J5QWRkcmVzc1xuICApO1xufVxuZnVuY3Rpb24gcHJlZGljdFByb3h5QWRkcmVzcyhpbXBsZW1lbnRhdGlvbiwgc2FsdCwgaW5pdERhdGEsIGRlcGxveWVyKSB7XG4gIGNvbnN0IGluaXRpYWxpemVDYWxsID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICBhYmk6IFtcbiAgICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcImRhdGFcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBuYW1lOiBcImluaXRpYWxpemVBY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIF0sXG4gICAgYXJnczogW2luaXREYXRhXSxcbiAgICBmdW5jdGlvbk5hbWU6IFwiaW5pdGlhbGl6ZUFjY291bnRcIlxuICB9KTtcbiAgY29uc3QgY29uc3RydWN0b3JBcmdzID0gZW5jb2RlQWJpUGFyYW1ldGVycyhcbiAgICBbeyB0eXBlOiBcImFkZHJlc3NcIiB9LCB7IHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICBbaW1wbGVtZW50YXRpb24sIGluaXRpYWxpemVDYWxsXVxuICApO1xuICBjb25zdCBuZXh1c1Byb3h5Q3JlYXRpb25Db2RlID0gXCIweDYwODA2MDQwNTI2MTAyYzg4MDM4MDM4MDYxMDAxNDgxNjEwMThjNTY1YjkyODMzOTgxMDE2MDQwODI4MjAzMTI2MTAxODg1NzgxNTE2MDAxNjAwMTYwYTAxYjAzODExNjkyOTA5MTkwODM4MzAzNjEwMTg4NTc2MDIwODEwMTUxOTA2MDAxNjAwMTYwNDAxYjAzODIxMTYxMDE4ODU3MDE5MjgxNjAxZjg1MDExMjE1NjEwMTg4NTc4MzUxNjEwMDZlNjEwMDY5ODI2MTAxYzU1NjViNjEwMThjNTY1Yjk0ODE4NjUyNjAyMDg2MDE5MzYwMjA4MzgzMDEwMTExNjEwMTg4NTc4MTVmOTI2MDIwODA5MzAxODY1ZTg2MDEwMTUyNjAwMTdmOTBiNzcyYzJjYjhhNTFhYTdhOGE2NWZjMjM1NDNjNmQwMjJkNWIzZjhlMmI5MmVlZDc5ZmJhN2VlZjgyOTMwMDVkODIzYjE1NjEwMTc2NTc3ZjM2MDg5NGExM2JhMWEzMjEwNjY3YzgyODQ5MmRiOThkY2EzZTIwNzZjYzM3MzVhOTIwYTNjYTUwNWQzODJiYmM4MDU0NjAwMTYwMDE2MGEwMWIwMzE5MTY4MjE3OTA1NTdmYmM3Y2Q3NWEyMGVlMjdmZDlhZGViYWIzMjA0MWY3NTUyMTRkYmM2YmZmYTkwY2MwMjI1YjM5ZGEyZTVjMmQzYjVmODBhMjgyNTExNTYxMDE1ZTU3NWY4MDkxNjEwMTQ2OTQ1MTkwODQ1YWY0M2QxNTYxMDE1NjU3M2Q5MTYxMDEzNzYxMDA2OTg0NjEwMWM1NTY1YjkyODM1MjNkNWY2MDIwODUwMTNlNjEwMWUwNTY1YjUwNWI2MDQwNTE2MDg5OTA4MTYxMDIzZjgyMzlmMzViNjA2MDkxNjEwMWUwNTY1YjUwNTA1MDM0MTU2MTAxNDg1NzYzYjM5ODk3OWY2MGUwMWI1ZjUyNjAwNDVmZmQ1YjYzNGM5YzhjZTM2MGUwMWI1ZjUyNjAwNDUyNjAyNDVmZmQ1YjVmODBmZDViNjA0MDUxOTE5MDYwMWYwMTYwMWYxOTE2ODIwMTYwMDE2MDAxNjA0MDFiMDM4MTExODM4MjEwMTc2MTAxYjE1NzYwNDA1MjU2NWI2MzRlNDg3YjcxNjBlMDFiNWY1MjYwNDE2MDA0NTI2MDI0NWZmZDViNjAwMTYwMDE2MDQwMWIwMzgxMTE2MTAxYjE1NzYwMWYwMTYwMWYxOTE2NjAyMDAxOTA1NjViOTA2MTAyMDQ1NzUwODA1MTE1NjEwMWY1NTc4MDUxOTA2MDIwMDFmZDViNjNkNmJkYTI3NTYwZTAxYjVmNTI2MDA0NWZmZDViODE1MTE1ODA2MTAyMzU1NzViNjEwMjE1NTc1MDkwNTY1YjYzOTk5NmIzMTU2MGUwMWI1ZjkwODE1MjYwMDE2MDAxNjBhMDFiMDM5MTkwOTExNjYwMDQ1MjYwMjQ5MGZkNWI1MDgwM2IxNTYxMDIwZDU2ZmU2MDgwNjA0MDUyMzYxNTYwNTE1NzdmMzYwODk0YTEzYmExYTMyMTA2NjdjODI4NDkyZGI5OGRjYTNlMjA3NmNjMzczNWE5MjBhM2NhNTA1ZDM4MmJiYzU0NWY5MDgxOTA2MDAxNjAwMTYwYTAxYjAzMTYzNjgyODAzNzgxMzY5MTVhZjQzZDVmODAzZTE1NjA0ZDU3M2Q1ZmYzNWIzZDVmZmQ1YjAwZmVhMjY0Njk3MDY2NzM1ODIyMTIyMDQxYjVmNzBhMzUxOTUyMTQyMjIzZjIyNTA0Y2E3YjRlNmQ5NzVmM2EzMDJkMTE0ZmY4MjA0NDJmY2Y4MTVhYzI2NDczNmY2YzYzNDMwMDA4MWIwMDMzXCI7XG4gIGNvbnN0IGluaXRDb2RlSGFzaCA9IGtlY2NhazI1NihcbiAgICBlbmNvZGVQYWNrZWQoW1wiYnl0ZXNcIiwgXCJieXRlc1wiXSwgW25leHVzUHJveHlDcmVhdGlvbkNvZGUsIGNvbnN0cnVjdG9yQXJnc10pXG4gICk7XG4gIHJldHVybiBnZXRDcmVhdGUyQWRkcmVzcyh7XG4gICAgYnl0ZWNvZGVIYXNoOiBpbml0Q29kZUhhc2gsXG4gICAgZnJvbTogZGVwbG95ZXIsXG4gICAgc2FsdFxuICB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL2Vucy50c1xuYXN5bmMgZnVuY3Rpb24gcmV2ZXJzZVJlc29sdmVFbnMoYWRkcmVzcykge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7RU5TX0FQSV9VUkx9L3JldmVyc2UvJHthZGRyZXNzfWApO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVOUyBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLFxuICAgICAgbmFtZTogZGF0YS5uYW1lIHx8IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZTpcIiwgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL3BvcHVwLnRzXG5pbXBvcnQgeyBycGNFcnJvcnMgfSBmcm9tIFwiQG1ldGFtYXNrL3JwYy1lcnJvcnNcIjtcbnZhciBQT1BVUF9XSURUSDIgPSA0MjA7XG52YXIgUE9QVVBfSEVJR0hUMiA9IDY1MDtcbnZhciBvcGVuUG9wdXAgPSAodXJsKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSAod2luZG93LmlubmVyV2lkdGggLSBQT1BVUF9XSURUSDIpIC8gMiArIHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCB0b3AgPSAod2luZG93LmlubmVySGVpZ2h0IC0gUE9QVVBfSEVJR0hUMikgLyAyICsgd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHBvcHVwSWQgPSBgd2FsbGV0XyR7d2luZG93Py5jcnlwdG8/LnJhbmRvbVVVSUQoKX1gO1xuICBjb25zdCBwb3B1cCA9IHdpbmRvdy5vcGVuKFxuICAgIHVybCxcbiAgICBwb3B1cElkLFxuICAgIGB3aWR0aD0ke1BPUFVQX1dJRFRIMn0sIGhlaWdodD0ke1BPUFVQX0hFSUdIVDJ9LCBsZWZ0PSR7bGVmdH0sIHRvcD0ke3RvcH1gXG4gICk7XG4gIHBvcHVwPy5mb2N1cygpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKFwiUG9wIHVwIHdpbmRvdyBmYWlsZWQgdG8gb3BlblwiKTtcbiAgfVxuICByZXR1cm4gcG9wdXA7XG59O1xudmFyIGNsb3NlUG9wdXAgPSAocG9wdXApID0+IHtcbiAgaWYgKHBvcHVwICYmICFwb3B1cC5jbG9zZWQpIHtcbiAgICBwb3B1cC5vcGVuZXI/LmZvY3VzKCk7XG4gICAgcG9wdXAuY2xvc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3N0cmluZ3MudHNcbnZhciBoZXhTdHJpbmdGcm9tTnVtYmVyID0gKG51bSkgPT4ge1xuICByZXR1cm4gYDB4JHtCaWdJbnQobnVtKS50b1N0cmluZygxNil9YDtcbn07XG52YXIgc2FmZUpzb25TdHJpbmdpZnkgPSAob2JqKSA9PiBKU09OLnN0cmluZ2lmeShcbiAgb2JqLFxuICAoXywgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgKyBcIm5cIiA6IHZhbHVlLFxuICAyXG4pO1xuXG4vLyBzcmMvY29tbXVuaWNhdG9yLnRzXG52YXIgQ29tbXVuaWNhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IGFwcE1ldGFkYXRhLCBvbkRpc2Nvbm5lY3RDYWxsYmFjayB9KSB7XG4gICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIHBvc3RzIGEgbWVzc2FnZSB0byB0aGUgcG9wdXAgd2luZG93XG4gICAgdGhpcy5wb3N0TWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBwb3B1cCA9IGF3YWl0IHRoaXMud2FpdEZvclBvcHVwTG9hZGVkKCk7XG4gICAgICBwb3B1cC5wb3N0TWVzc2FnZShtZXNzYWdlLCB0aGlzLnVybC5vcmlnaW4pO1xuICAgIH07XG4gICAgLy8gcG9zdHMgYSByZXF1ZXN0IHRvIHRoZSBwb3B1cCB3aW5kb3cgYW5kIHdhaXRzIGZvciBhIHJlc3BvbnNlXG4gICAgdGhpcy5wb3N0UmVxdWVzdEFuZFdhaXRGb3JSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm9uTWVzc2FnZShcbiAgICAgICAgKHsgcmVxdWVzdElkIH0pID0+IHJlcXVlc3RJZCA9PT0gcmVxdWVzdC5yZXF1ZXN0SWRcbiAgICAgICk7XG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9O1xuICAgIC8vIGxpc3RlbnMgZm9yIG1lc3NhZ2VzIGZyb20gdGhlIHBvcHVwIHdpbmRvdyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcHJlZGljYXRlXG4gICAgdGhpcy5vbk1lc3NhZ2UgPSAocHJlZGljYXRlKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMudXJsLm9yaWdpbikgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnNldChsaXN0ZW5lciwgeyByZWplY3QgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGNsb3NlcyB0aGUgcG9wdXAsIHJlamVjdHMgYWxsIHJlcXVlc3RzIGFuZCBjbGVhcnMgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5vblJlcXVlc3RDYW5jZWxsZWQgPSAoKSA9PiB7XG4gICAgICBjbG9zZVBvcHVwKHRoaXMucG9wdXApO1xuICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKCh7IHJlamVjdCB9LCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICByZWplY3QocHJvdmlkZXJFcnJvcnMudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8vIHdhaXRzIGZvciB0aGUgcG9wdXAgd2luZG93IHRvIGZ1bGx5IGxvYWQgYW5kIHRoZW4gc2VuZHMgYSB2ZXJzaW9uIG1lc3NhZ2VcbiAgICB0aGlzLndhaXRGb3JQb3B1cExvYWRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBvcHVwICYmICF0aGlzLnBvcHVwLmNsb3NlZCkge1xuICAgICAgICB0aGlzLnBvcHVwLmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5wb3B1cCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcHVwID0gb3BlblBvcHVwKHRoaXMudXJsKTtcbiAgICAgIHRoaXMub25NZXNzYWdlKFxuICAgICAgICAoeyBldmVudCB9KSA9PiBldmVudCA9PT0gXCJQT1BVUF9VTkxPQURFRFwiIC8qIFBPUFVQX1VOTE9BREVEICovXG4gICAgICApLnRoZW4odGhpcy5vblJlcXVlc3RDYW5jZWxsZWQpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbk1lc3NhZ2UoXG4gICAgICAgICh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlNES19ESVNDT05ORUNUXCIgLyogU0RLX0RJU0NPTk5FQ1QgKi9cbiAgICAgICkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0Q2FsbGJhY2s/LigpO1xuICAgICAgICB0aGlzLm9uUmVxdWVzdENhbmNlbGxlZCgpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5vbk1lc3NhZ2UoXG4gICAgICAgICh7IGV2ZW50IH0pID0+IGV2ZW50ID09PSBcIlBPUFVQX0xPQURFRFwiIC8qIFBPUFVQX0xPQURFRCAqL1xuICAgICAgKS50aGVuKChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNoYWluSWQ6IERFRkFVTFRfQ0hBSU5fSUQsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgYXBwTWV0YWRhdGE6IHRoaXMuYXBwTWV0YWRhdGEsXG4gICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBTREtfVkVSU0lPTlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnQ6IFwiUE9QVVBfQVBQX0NPTlRFWFRcIiAvKiBQT1BVUF9BUFBfQ09OVEVYVCAqLyxcbiAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLnJlcXVlc3RJZFxuICAgICAgICB9KTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucG9wdXApIHRocm93IHJwY0Vycm9yczIuaW50ZXJuYWwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXA7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMudXJsID0gbmV3IFVSTChTREtfQkFDS0VORF9VUkwpO1xuICAgIHRoaXMuYXBwTWV0YWRhdGEgPSBhcHBNZXRhZGF0YTtcbiAgICB0aGlzLm9uRGlzY29ubmVjdENhbGxiYWNrID0gb25EaXNjb25uZWN0Q2FsbGJhY2s7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9wcm92aWRlci50c1xuaW1wb3J0IHtcbiAgZXJyb3JDb2RlcyxcbiAgcHJvdmlkZXJFcnJvcnMgYXMgcHJvdmlkZXJFcnJvcnMyLFxuICBycGNFcnJvcnMgYXMgcnBjRXJyb3JzNCxcbiAgc2VyaWFsaXplRXJyb3Jcbn0gZnJvbSBcIkBtZXRhbWFzay9ycGMtZXJyb3JzXCI7XG5cbi8vIHNyYy9zdG9yYWdlL3N0b3JhZ2UudHNcbnZhciBtZW1vcnlTdG9yYWdlID0ge307XG52YXIgR2VtaW5pU3RvcmFnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHNjb3BlID0gXCJAZ2VtaW5pXCIsXG4gICAgbW9kdWxlID0gXCJ3YWxsZXRcIlxuICB9ID0ge30pIHtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gIH1cbiAgc2NvcGVkS2V5KGtleSkge1xuICAgIHJldHVybiBgJHt0aGlzLnNjb3BlfS4ke3RoaXMubW9kdWxlfS4ke2tleX1gO1xuICB9XG4gIGFzeW5jIHN0b3JlT2JqZWN0KGtleSwgaXRlbSkge1xuICAgIGNvbnN0IGpzb24gPSBzYWZlSnNvblN0cmluZ2lmeShpdGVtKTtcbiAgICBhd2FpdCB0aGlzLnNldEl0ZW0oa2V5LCBqc29uKTtcbiAgfVxuICBhc3luYyBsb2FkT2JqZWN0KGtleSwgZmFsbGJhY2spIHtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBhd2FpdCB0aGlzLnN0b3JlT2JqZWN0KGtleSwgZmFsbGJhY2spO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaXRlbSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgSlNPTiBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHNjb3BlZCA9IHRoaXMuc2NvcGVkS2V5KGtleSk7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHNjb3BlZCwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLCB1c2luZyBtZW1vcnkgc3RvcmFnZVwiLCBlKTtcbiAgICAgIG1lbW9yeVN0b3JhZ2Vbc2NvcGVkXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXRJdGVtKGtleSkge1xuICAgIGNvbnN0IHNjb3BlZCA9IHRoaXMuc2NvcGVkS2V5KGtleSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzY29wZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLCB1c2luZyBtZW1vcnkgc3RvcmFnZVwiLCBlKTtcbiAgICAgIHJldHVybiBtZW1vcnlTdG9yYWdlW3Njb3BlZF0gfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICBjb25zdCBzY29wZWQgPSB0aGlzLnNjb3BlZEtleShrZXkpO1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzY29wZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImxvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLCB1c2luZyBtZW1vcnkgc3RvcmFnZVwiLCBlKTtcbiAgICAgIGRlbGV0ZSBtZW1vcnlTdG9yYWdlW3Njb3BlZF07XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlbW92ZUl0ZW1zKGtleXMpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLnJlbW92ZUl0ZW0oa2V5KSkpO1xuICB9XG59O1xuXG4vLyBzcmMvc3RvcmFnZS9zdG9yYWdlSW50ZXJmYWNlLnRzXG52YXIgU1RPUkFHRV9FVEhfQUNDT1VOVFNfS0VZID0gXCJldGgtYWNjb3VudHNcIjtcbnZhciBTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZID0gXCJldGgtYWN0aXZlLWNoYWluXCI7XG52YXIgU1RPUkFHRV9QQVNTS0VZX0NSRURFTlRJQUxfS0VZID0gXCJwYXNza2V5LWNyZWRlbnRpYWxcIjtcbnZhciBTVE9SQUdFX1BSRVNFUlZFRF9QQVNTS0VZX0NSRURFTlRJQUxTX0tFWSA9IFwicHJlc2VydmVkLXBhc3NrZXktY3JlZGVudGlhbHNcIjtcbnZhciBTVE9SQUdFX1NNQVJUX0FDQ09VTlRfS0VZID0gXCJzbWFydC1hY2NvdW50XCI7XG52YXIgU1RPUkFHRV9TRVRUSU5HU19LRVkgPSBcInNldHRpbmdzXCI7XG52YXIgU1RPUkFHRV9XQ19SRVFVRVNUU19LRVkgPSBcIndjLXJlcXVlc3RzXCI7XG5cbi8vIHNyYy93YWxsZXRzL3dhbGxldC50c1xuZnVuY3Rpb24gaXNDaGFpblN1cHBvcnRlZEJ5R2VtaW5pU3coY2hhaW5JZCkge1xuICByZXR1cm4gU1VQUE9SVEVEX0NIQUlOX0lEUy5pbmNsdWRlcyhcbiAgICBjaGFpbklkXG4gICk7XG59XG52YXIgR2VtaW5pV2FsbGV0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXBwTWV0YWRhdGEsXG4gICAgY2hhaW4sXG4gICAgb25EaXNjb25uZWN0Q2FsbGJhY2ssXG4gICAgc3RvcmFnZVxuICB9KSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY2hhaW4gPSB7IGlkOiBERUZBVUxUX0NIQUlOX0lEIH07XG4gICAgdGhpcy5jb21tdW5pY2F0b3IgPSBuZXcgQ29tbXVuaWNhdG9yKHtcbiAgICAgIGFwcE1ldGFkYXRhLFxuICAgICAgb25EaXNjb25uZWN0Q2FsbGJhY2tcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlIHx8IG5ldyBHZW1pbmlTdG9yYWdlKCk7XG4gICAgY29uc3QgZmFsbGJhY2tDaGFpbklkID0gY2hhaW4/LmlkID8/IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgY29uc3QgZmFsbGJhY2tScGNVcmwgPSBjaGFpbj8ucnBjVXJsID8/IGdldERlZmF1bHRScGNVcmwoZmFsbGJhY2tDaGFpbklkKTtcbiAgICBjb25zdCBkZWZhdWx0Q2hhaW4gPSB7XG4gICAgICBpZDogZmFsbGJhY2tDaGFpbklkLFxuICAgICAgcnBjVXJsOiBmYWxsYmFja1JwY1VybFxuICAgIH07XG4gICAgdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMuaW5pdGlhbGl6ZUZyb21TdG9yYWdlKGRlZmF1bHRDaGFpbik7XG4gIH1cbiAgYXN5bmMgaW5pdGlhbGl6ZUZyb21TdG9yYWdlKGRlZmF1bHRDaGFpbikge1xuICAgIGNvbnN0IGZhbGxiYWNrQ2hhaW4gPSB7XG4gICAgICAuLi5kZWZhdWx0Q2hhaW4sXG4gICAgICBycGNVcmw6IGRlZmF1bHRDaGFpbi5ycGNVcmwgfHwgZ2V0RGVmYXVsdFJwY1VybChkZWZhdWx0Q2hhaW4uaWQpXG4gICAgfTtcbiAgICBjb25zdCBbc3RvcmVkQ2hhaW4sIHN0b3JlZEFjY291bnRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuc3RvcmFnZS5sb2FkT2JqZWN0KFxuICAgICAgICBTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZLFxuICAgICAgICBmYWxsYmFja0NoYWluXG4gICAgICApLFxuICAgICAgdGhpcy5zdG9yYWdlLmxvYWRPYmplY3QoXG4gICAgICAgIFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSxcbiAgICAgICAgdGhpcy5hY2NvdW50c1xuICAgICAgKVxuICAgIF0pO1xuICAgIHRoaXMuY2hhaW4gPSB7XG4gICAgICAuLi5zdG9yZWRDaGFpbixcbiAgICAgIHJwY1VybDogc3RvcmVkQ2hhaW4ucnBjVXJsIHx8IGdldERlZmF1bHRScGNVcmwoc3RvcmVkQ2hhaW4uaWQpXG4gICAgfTtcbiAgICB0aGlzLmFjY291bnRzID0gc3RvcmVkQWNjb3VudHM7XG4gIH1cbiAgYXN5bmMgZW5zdXJlSW5pdGlhbGl6ZWQoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0UHJvbWlzZTtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBldmVudDogXCJTREtfQ09OTkVDVFwiIC8qIFNES19DT05ORUNUICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgdGhpcy5hY2NvdW50cyA9IHJlc3BvbnNlLmRhdGEuYWRkcmVzcyA/IFtyZXNwb25zZS5kYXRhLmFkZHJlc3NdIDogW107XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLnN0b3JlT2JqZWN0KFNUT1JBR0VfRVRIX0FDQ09VTlRTX0tFWSwgdGhpcy5hY2NvdW50cyk7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHM7XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksIHRoaXMuYWNjb3VudHMpO1xuICB9XG4gIGFzeW5jIHN3aXRjaENoYWluKHsgaWQgfSkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICBpZiAoaXNDaGFpblN1cHBvcnRlZEJ5R2VtaW5pU3coaWQpKSB7XG4gICAgICB0aGlzLmNoYWluID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgcnBjVXJsOiBnZXREZWZhdWx0UnBjVXJsKGlkKVxuICAgICAgfTtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zdG9yZU9iamVjdChTVE9SQUdFX0VUSF9BQ1RJVkVfQ0hBSU5fS0VZLCB0aGlzLmNoYWluKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2VUb1BvcHVwKHtcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW4uaWQsXG4gICAgICBkYXRhOiBpZCxcbiAgICAgIGV2ZW50OiBcIlNES19TV0lUQ0hfQ0hBSU5cIiAvKiBTREtfU1dJVENIX0NIQUlOICovLFxuICAgICAgb3JpZ2luOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZXJyb3IgPz8gXCJVbnN1cHBvcnRlZCBjaGFpbi5cIjtcbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHhEYXRhKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHR4RGF0YSxcbiAgICAgIGV2ZW50OiBcIlNES19TRU5EX1RSQU5TQUNUSU9OXCIgLyogU0RLX1NFTkRfVFJBTlNBQ1RJT04gKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBzaWduRGF0YSh7XG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHsgbWVzc2FnZSB9LFxuICAgICAgZXZlbnQ6IFwiU0RLX1NJR05fREFUQVwiIC8qIFNES19TSUdOX0RBVEEgKi8sXG4gICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuICBhc3luYyBzaWduVHlwZWREYXRhKHtcbiAgICBtZXNzYWdlLFxuICAgIHR5cGVzLFxuICAgIHByaW1hcnlUeXBlLFxuICAgIGRvbWFpblxuICB9KSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZG9tYWluLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgdHlwZXNcbiAgICAgIH0sXG4gICAgICBldmVudDogXCJTREtfU0lHTl9UWVBFRF9EQVRBXCIgLyogU0RLX1NJR05fVFlQRURfREFUQSAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG4gIGFzeW5jIG9wZW5TZXR0aW5ncygpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgYXdhaXQgdGhpcy5zZW5kTWVzc2FnZVRvUG9wdXAoe1xuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgIGRhdGE6IHt9LFxuICAgICAgZXZlbnQ6IFwiU0RLX09QRU5fU0VUVElOR1NcIiAvKiBTREtfT1BFTl9TRVRUSU5HUyAqLyxcbiAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgIH0pO1xuICB9XG4gIHNlbmRNZXNzYWdlVG9Qb3B1cChyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbXVuaWNhdG9yLnBvc3RSZXF1ZXN0QW5kV2FpdEZvclJlc3BvbnNlKHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICByZXF1ZXN0SWQ6IHdpbmRvdz8uY3J5cHRvPy5yYW5kb21VVUlEKClcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3Byb3ZpZGVyLnV0aWxzLnRzXG5pbXBvcnQgeyBycGNFcnJvcnMgYXMgcnBjRXJyb3JzMyB9IGZyb20gXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiO1xuaW1wb3J0IHsgaXNIZXggfSBmcm9tIFwidmllbVwiO1xudmFyIGZldGNoUnBjUmVxdWVzdCA9IGFzeW5jIChyZXF1ZXN0LCBycGNVcmwpID0+IHtcbiAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgLi4ucmVxdWVzdCxcbiAgICBpZDogd2luZG93Py5jcnlwdG8/LnJhbmRvbVVVSUQoKSxcbiAgICBqc29ucnBjOiBcIjIuMFwiXG4gIH07XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHdpbmRvdy5mZXRjaChycGNVcmwsIHtcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgbW9kZTogXCJjb3JzXCJcbiAgfSk7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVJwY1JlcXVlc3RBcmdzKGFyZ3MpIHtcbiAgaWYgKCFhcmdzIHx8IHR5cGVvZiBhcmdzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICB0aHJvdyBycGNFcnJvcnMzLmludmFsaWRQYXJhbXMoe1xuICAgICAgbWVzc2FnZTogXCJFeHBlY3RlZCBhIHNpbmdsZSwgbm9uLWFycmF5LCBvYmplY3QgYXJndW1lbnQuXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSBhcmdzO1xuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCBtZXRob2QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzMy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgIG1lc3NhZ2U6IFwiJ2FyZ3MubWV0aG9kJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbXMgIT09IHZvaWQgMCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBycGNFcnJvcnMzLmludmFsaWRQYXJhbXMoe1xuICAgICAgbWVzc2FnZTogXCInYXJncy5wYXJhbXMnIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5IGlmIHByb3ZpZGVkLlwiXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZW5kVmFsdWVzVG9CaWdJbnQodHgpIHtcbiAgY29uc3QgRklFTERTX1RPX05PUk1BTElaRSA9IFtcInZhbHVlXCIsIFwiZ2FzXCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm1heEZlZVBlckdhc1wiXTtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHsgLi4udHggfTtcbiAgZm9yIChjb25zdCBmaWVsZCBvZiBGSUVMRFNfVE9fTk9STUFMSVpFKSB7XG4gICAgaWYgKCEoZmllbGQgaW4gdHgpKSBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHR4W2ZpZWxkXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSBjb250aW51ZTtcbiAgICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgICBub3JtYWxpemVkW2ZpZWxkXSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvcHJvdmlkZXIudHNcbnZhciBHZW1pbmlXYWxsZXRQcm92aWRlciA9IGNsYXNzIGV4dGVuZHMgUHJvdmlkZXJFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlckNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53YWxsZXQgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gcHJvdmlkZXJDb25maWc7XG4gICAgY29uc3QgdXNlckRpc2Nvbm5lY3RDYWxsYmFjayA9IHByb3ZpZGVyQ29uZmlnLm9uRGlzY29ubmVjdENhbGxiYWNrO1xuICAgIHRoaXMud2FsbGV0ID0gbmV3IEdlbWluaVdhbGxldCh7XG4gICAgICAuLi5wcm92aWRlckNvbmZpZyxcbiAgICAgIG9uRGlzY29ubmVjdENhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHVzZXJEaXNjb25uZWN0Q2FsbGJhY2s/LigpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAgICB0cnkge1xuICAgICAgdmFsaWRhdGVScGNSZXF1ZXN0QXJncyhhcmdzKTtcbiAgICAgIGlmICghdGhpcy53YWxsZXQ/LmFjY291bnRzPy5sZW5ndGgpIHtcbiAgICAgICAgc3dpdGNoIChhcmdzLm1ldGhvZCkge1xuICAgICAgICAgIGNhc2UgXCJldGhfcmVxdWVzdEFjY291bnRzXCI6IHtcbiAgICAgICAgICAgIGlmICghdGhpcy53YWxsZXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXNlckRpc2Nvbm5lY3RDYWxsYmFjayA9IHRoaXMuY29uZmlnLm9uRGlzY29ubmVjdENhbGxiYWNrO1xuICAgICAgICAgICAgICB0aGlzLndhbGxldCA9IG5ldyBHZW1pbmlXYWxsZXQoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdENhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB1c2VyRGlzY29ubmVjdENhbGxiYWNrPy4oKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndhbGxldC5jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgdGhpcy53YWxsZXQuYWNjb3VudHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuZXRfdmVyc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgICAgY2FzZSBcImV0aF9jaGFpbklkXCI6XG4gICAgICAgICAgICByZXR1cm4gaGV4U3RyaW5nRnJvbU51bWJlcihERUZBVUxUX0NIQUlOX0lEKTtcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBwcm92aWRlckVycm9yczIudW5hdXRob3JpemVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgcmVxdWVzdFBhcmFtcztcbiAgICAgIHN3aXRjaCAoYXJncy5tZXRob2QpIHtcbiAgICAgICAgY2FzZSBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIjpcbiAgICAgICAgY2FzZSBcImV0aF9hY2NvdW50c1wiOlxuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy53YWxsZXQuYWNjb3VudHM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuZXRfdmVyc2lvblwiOlxuICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy53YWxsZXQuY2hhaW4uaWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJldGhfY2hhaW5JZFwiOlxuICAgICAgICAgIHJlc3BvbnNlID0gaGV4U3RyaW5nRnJvbU51bWJlcih0aGlzLndhbGxldC5jaGFpbi5pZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwZXJzb25hbF9zaWduXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc2lnblwiOlxuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNpZ25EYXRhKHtcbiAgICAgICAgICAgIGFjY291bnQ6IHJlcXVlc3RQYXJhbXNbMV0sXG4gICAgICAgICAgICBtZXNzYWdlOiByZXF1ZXN0UGFyYW1zWzBdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0LnRyYW5zYWN0aW9uUmVqZWN0ZWQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlLmhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X3NlbmRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBhcmdzLnBhcmFtcztcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gY29udmVydFNlbmRWYWx1ZXNUb0JpZ0ludChyZXF1ZXN0UGFyYW1zWzBdKTtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnNlbmRUcmFuc2FjdGlvbihyZXF1ZXN0UGFyYW1zKTtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9yczQudHJhbnNhY3Rpb25SZWplY3RlZChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuaGFzaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpblwiOiB7XG4gICAgICAgICAgY29uc3QgcmF3UGFyYW1zID0gYXJncy5wYXJhbXM7XG4gICAgICAgICAgbGV0IGNoYWluSWQ7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3UGFyYW1zKSAmJiByYXdQYXJhbXNbMF0/LmNoYWluSWQpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChyYXdQYXJhbXNbMF0uY2hhaW5JZCwgMTYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmF3UGFyYW1zICYmIHR5cGVvZiByYXdQYXJhbXMgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIHJhd1BhcmFtcyAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJhd1BhcmFtcy5pZCkpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSByYXdQYXJhbXMuaWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHJwY0Vycm9yczQuaW52YWxpZFBhcmFtcyhcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIGNoYWluIGlkIGFyZ3VtZW50LiBFeHBlY3RlZCBbeyBjaGFpbklkOiBoZXhfc3RyaW5nIH1dIG9yIHsgaWQ6IG51bWJlciB9LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0LnN3aXRjaENoYWluKHsgaWQ6IGNoYWluSWQgfSk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm92aWRlckVycm9yczIuY3VzdG9tKHsgY29kZTogNDkwMiwgbWVzc2FnZTogcmVzcG9uc2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHRoaXMuZW1pdChcImNoYWluQ2hhbmdlZFwiLCBoZXhTdHJpbmdGcm9tTnVtYmVyKGNoYWluSWQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjFcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhX3YyXCI6XG4gICAgICAgIGNhc2UgXCJldGhfc2lnblR5cGVkRGF0YV92M1wiOlxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHlwZWREYXRhXCI6IHtcbiAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gYXJncy5wYXJhbXM7XG4gICAgICAgICAgY29uc3Qgc2lnbmVkVHlwZWREYXRhUGFyYW1zID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNbMV1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXQuc2lnblR5cGVkRGF0YSh7XG4gICAgICAgICAgICBhY2NvdW50OiByZXF1ZXN0UGFyYW1zWzBdLFxuICAgICAgICAgICAgZG9tYWluOiBzaWduZWRUeXBlZERhdGFQYXJhbXMuZG9tYWluLFxuICAgICAgICAgICAgbWVzc2FnZTogc2lnbmVkVHlwZWREYXRhUGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogc2lnbmVkVHlwZWREYXRhUGFyYW1zLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgdHlwZXM6IHNpZ25lZFR5cGVkRGF0YVBhcmFtcy50eXBlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC50cmFuc2FjdGlvblJlamVjdGVkKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBub3QgeWV0IGltcGxlbWVudGVkIG9yIHVuY2xlYXIgaWYgd2Ugc3VwcG9ydFxuICAgICAgICBjYXNlIFwiZXRoX2VjUmVjb3ZlclwiOlxuICAgICAgICBjYXNlIFwiZXRoX3N1YnNjcmliZVwiOlxuICAgICAgICBjYXNlIFwiZXRoX3Vuc3Vic2NyaWJlXCI6XG4gICAgICAgIGNhc2UgXCJwZXJzb25hbF9lY1JlY292ZXJcIjpcbiAgICAgICAgY2FzZSBcImV0aF9zaWduVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF93YXRjaEFzc2V0XCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfc2VuZENhbGxzXCI6XG4gICAgICAgIGNhc2UgXCJ3YWxsZXRfZ2V0Q2FsbHNTdGF0dXNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9nZXRDYXBhYmlsaXRpZXNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9zaG93Q2FsbHNTdGF0dXNcIjpcbiAgICAgICAgY2FzZSBcIndhbGxldF9ncmFudFBlcm1pc3Npb25zXCI6XG4gICAgICAgICAgdGhyb3cgcnBjRXJyb3JzNC5tZXRob2ROb3RTdXBwb3J0ZWQoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICBjYXNlIFwiZXRoX3NpZ25cIjpcbiAgICAgICAgY2FzZSBcImV0aF9jb2luYmFzZVwiOlxuICAgICAgICBjYXNlIFwid2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW5cIjpcbiAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0Lm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICAvLyBjYWxsIHJwYyBkaXJlY3RseSBmb3IgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCF0aGlzLndhbGxldC5jaGFpbi5ycGNVcmwpXG4gICAgICAgICAgICB0aHJvdyBycGNFcnJvcnM0LmludGVybmFsKFxuICAgICAgICAgICAgICBgUlBDIFVSTCBtaXNzaW5nIGZvciBjdXJyZW50IGNoYWluICgke3RoaXMud2FsbGV0LmNoYWluLmlkfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBmZXRjaFJwY1JlcXVlc3QoYXJncywgdGhpcy53YWxsZXQuY2hhaW4ucnBjVXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgeyBjb2RlIH0gPSBlcnJvcjtcbiAgICAgIGlmIChjb2RlID09PSBlcnJvckNvZGVzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCkgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gIH1cbiAgLy8gY3VzdG9tIHdhbGxldCBmdW5jdGlvbiB0byBvcGVuIHNldHRpbmdzIHBhZ2VcbiAgYXN5bmMgb3BlblNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMud2FsbGV0Py5vcGVuU2V0dGluZ3MoKTtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLndhbGxldCkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuY29uZmlnLnN0b3JhZ2UgfHwgbmV3IEdlbWluaVN0b3JhZ2UoKTtcbiAgICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVkpO1xuICAgICAgYXdhaXQgc3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVkpO1xuICAgIH1cbiAgICB0aGlzLndhbGxldCA9IG51bGw7XG4gICAgdGhpcy5jb25maWcub25EaXNjb25uZWN0Q2FsbGJhY2s/LigpO1xuICAgIGF3YWl0IHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwgXCJVc2VyIGluaXRpYXRlZCBkaXNjb25uZWN0aW9uXCIpO1xuICAgIGF3YWl0IHRoaXMuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBbXSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBDb21tdW5pY2F0b3IsXG4gIERFRkFVTFRfQ0hBSU5fSUQsXG4gIEdlbWluaVNka0V2ZW50LFxuICBHZW1pbmlTdG9yYWdlLFxuICBHZW1pbmlXYWxsZXQsXG4gIEdlbWluaVdhbGxldFByb3ZpZGVyLFxuICBQT1BVUF9IRUlHSFQsXG4gIFBPUFVQX1dJRFRILFxuICBQbGF0Zm9ybVR5cGUsXG4gIFByb3ZpZGVyRXZlbnRFbWl0dGVyLFxuICBTREtfQkFDS0VORF9VUkwsXG4gIFNES19WRVJTSU9OLFxuICBTVE9SQUdFX0VUSF9BQ0NPVU5UU19LRVksXG4gIFNUT1JBR0VfRVRIX0FDVElWRV9DSEFJTl9LRVksXG4gIFNUT1JBR0VfUEFTU0tFWV9DUkVERU5USUFMX0tFWSxcbiAgU1RPUkFHRV9QUkVTRVJWRURfUEFTU0tFWV9DUkVERU5USUFMU19LRVksXG4gIFNUT1JBR0VfU0VUVElOR1NfS0VZLFxuICBTVE9SQUdFX1NNQVJUX0FDQ09VTlRfS0VZLFxuICBTVE9SQUdFX1dDX1JFUVVFU1RTX0tFWSxcbiAgYmFzZTY0VG9IZXgsXG4gIGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nLFxuICBjYWxjdWxhdGVWMUFkZHJlc3MsXG4gIGNhbGN1bGF0ZVdhbGxldEFkZHJlc3MsXG4gIGNsb3NlUG9wdXAsXG4gIGNvbnZlcnRTZW5kVmFsdWVzVG9CaWdJbnQsXG4gIGRlY29kZUJhc2U2NCxcbiAgZW5jb2RlQmFzZTY0LFxuICBmZXRjaFJwY1JlcXVlc3QsXG4gIGdlbmVyYXRlQXV0aGVudGljYXRvcklkSGFzaCxcbiAgaGV4U3RyaW5nRnJvbU51bWJlcixcbiAgaXNDaGFpblN1cHBvcnRlZEJ5R2VtaW5pU3csXG4gIG9wZW5Qb3B1cCxcbiAgcmV2ZXJzZVJlc29sdmVFbnMsXG4gIHNhZmVKc29uU3RyaW5naWZ5LFxuICB1dGY4U3RyaW5nVG9CdWZmZXIsXG4gIHZhbGlkYXRlUnBjUmVxdWVzdEFyZ3MsXG4gIHZhbGlkYXRlV2ViQXV0aG5LZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@gemini-wallet/core/dist/index.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/baseAccount.js":
/*!************************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/baseAccount.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   baseAccount: function() { return /* binding */ baseAccount; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\nfunction baseAccount(parameters = {}) {\n    let walletProvider;\n    let accountsChanged;\n    let chainChanged;\n    let disconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((config) => ({\n        id: 'baseAccount',\n        name: 'Base Account',\n        rdns: 'app.base.account',\n        type: 'baseAccount',\n        async connect({ chainId, withCapabilities } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                    params: [],\n                })).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return {\n                    // TODO(v3): Make `withCapabilities: true` default behavior\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            provider.disconnect();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return (await provider.request({\n                method: 'eth_accounts',\n            })).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = (await provider.request({\n                method: 'eth_chainId',\n            }));\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                const preference = (() => {\n                    if (typeof parameters.preference === 'string')\n                        return { options: parameters.preference };\n                    return {\n                        ...parameters.preference,\n                        options: parameters.preference?.options ?? 'all',\n                    };\n                })();\n                const { createBaseAccountSDK } = await __webpack_require__.e(/*! import() */ \"node_modules_base-org_account_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @base-org/account */ \"../node_modules/@base-org/account/dist/index.js\"));\n                const sdk = createBaseAccountSDK({\n                    ...parameters,\n                    appChainIds: config.chains.map((x) => x.id),\n                    preference,\n                });\n                walletProvider = sdk.getProvider();\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chain.id) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                // Indicates chain is not added to provider\n                if (error.code === 4902) {\n                    try {\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else\n                            blockExplorerUrls = chain.blockExplorers?.default.url\n                                ? [chain.blockExplorers?.default.url]\n                                : [];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [addEthereumChain],\n                        });\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                    }\n                }\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect(_error) {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n        },\n    }));\n}\n//# sourceMappingURL=baseAccount.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9iYXNlQWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0U7QUFDb0I7QUFDckYsb0NBQW9DO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEIsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWMsZ0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEUsMkNBQTJDLDBEQUF3QjtBQUNuRTtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUF3QjtBQUN0RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYyxnREFBVTtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsd0JBQXdCLHVCQUF1QixRQUFRLG9OQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWdCLEtBQUssZ0VBQXVCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsaURBQVcsWUFBWTtBQUMvRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUF3QjtBQUMxRDtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFnQjtBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdEQUFVO0FBQzVELGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy93YWdtaS9ub2RlX21vZHVsZXMvQHdhZ21pL2Nvbm5lY3RvcnMvZGlzdC9lc20vYmFzZUFjY291bnQuanM/ZjgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvciwgY3JlYXRlQ29ubmVjdG9yLCB9IGZyb20gJ0B3YWdtaS9jb3JlJztcbmltcG9ydCB7IGdldEFkZHJlc3MsIG51bWJlclRvSGV4LCBTd2l0Y2hDaGFpbkVycm9yLCBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsIH0gZnJvbSAndmllbSc7XG5leHBvcnQgZnVuY3Rpb24gYmFzZUFjY291bnQocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgbGV0IHdhbGxldFByb3ZpZGVyO1xuICAgIGxldCBhY2NvdW50c0NoYW5nZWQ7XG4gICAgbGV0IGNoYWluQ2hhbmdlZDtcbiAgICBsZXQgZGlzY29ubmVjdDtcbiAgICByZXR1cm4gY3JlYXRlQ29ubmVjdG9yKChjb25maWcpID0+ICh7XG4gICAgICAgIGlkOiAnYmFzZUFjY291bnQnLFxuICAgICAgICBuYW1lOiAnQmFzZSBBY2NvdW50JyxcbiAgICAgICAgcmRuczogJ2FwcC5iYXNlLmFjY291bnQnLFxuICAgICAgICB0eXBlOiAnYmFzZUFjY291bnQnLFxuICAgICAgICBhc3luYyBjb25uZWN0KHsgY2hhaW5JZCwgd2l0aENhcGFiaWxpdGllcyB9ID0ge30pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgIH0pKS5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHRoaXMub25DaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3dpdGNoIHRvIGNoYWluIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgJiYgY3VycmVudENoYWluSWQgIT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBhd2FpdCB0aGlzLnN3aXRjaENoYWluKHsgY2hhaW5JZCB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiBjdXJyZW50Q2hhaW5JZCB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluSWQgPSBjaGFpbj8uaWQgPz8gY3VycmVudENoYWluSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8odjMpOiBNYWtlIGB3aXRoQ2FwYWJpbGl0aWVzOiB0cnVlYCBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiAod2l0aENhcGFiaWxpdGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhY2NvdW50cy5tYXAoKGFkZHJlc3MpID0+ICh7IGFkZHJlc3MsIGNhcGFiaWxpdGllczoge30gfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFjY291bnRzKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY3VycmVudENoYWluSWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICgvKHVzZXIgY2xvc2VkIG1vZGFsfGFjY291bnRzIHJlY2VpdmVkIGlzIGVtcHR5fHVzZXIgZGVuaWVkIGFjY291bnR8cmVxdWVzdCByZWplY3RlZCkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2FjY291bnRzJyxcbiAgICAgICAgICAgIH0pKS5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoY2hhaW5JZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFByb3ZpZGVyKCkge1xuICAgICAgICAgICAgaWYgKCF3YWxsZXRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMucHJlZmVyZW5jZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBvcHRpb25zOiBwYXJhbWV0ZXJzLnByZWZlcmVuY2UgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMucHJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHBhcmFtZXRlcnMucHJlZmVyZW5jZT8ub3B0aW9ucyA/PyAnYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlQmFzZUFjY291bnRTREsgfSA9IGF3YWl0IGltcG9ydCgnQGJhc2Utb3JnL2FjY291bnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZGsgPSBjcmVhdGVCYXNlQWNjb3VudFNESyh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGFwcENoYWluSWRzOiBjb25maWcuY2hhaW5zLm1hcCgoeCkgPT4geC5pZCksXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXIgPSBzZGsuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YWxsZXRQcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgaXNBdXRob3JpemVkKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFhY2NvdW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzd2l0Y2hDaGFpbih7IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIsIGNoYWluSWQgfSkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBjb25maWcuY2hhaW5zLmZpbmQoKGNoYWluKSA9PiBjaGFpbi5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluLmlkKSB9XSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgY2hhaW4gaXMgbm90IGFkZGVkIHRvIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQ5MDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9ja0V4cGxvcmVyVXJscztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5ibG9ja0V4cGxvcmVyVXJscylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyA9IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIuYmxvY2tFeHBsb3JlclVybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHMgPSBjaGFpbi5ibG9ja0V4cGxvcmVycz8uZGVmYXVsdC51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ucnBjVXJscz8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMgPSBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLnJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyA9IFtjaGFpbi5ycGNVcmxzLmRlZmF1bHQ/Lmh0dHBbMF0gPz8gJyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkRXRoZXJldW1DaGFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmNoYWluTmFtZSA/PyBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25VcmxzOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5pY29uVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ubmF0aXZlQ3VycmVuY3kgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4ubmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbYWRkRXRoZXJldW1DaGFpbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYWluQ2hhbmdlZChjaGFpbikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihjaGFpbik7XG4gICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7IGNoYWluSWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdChfZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlQWNjb3VudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/baseAccount.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coinbaseWallet: function() { return /* binding */ coinbaseWallet; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\ncoinbaseWallet.type = 'coinbaseWallet';\nfunction coinbaseWallet(parameters = {}) {\n    if (parameters.version === '3' || parameters.headlessMode)\n        return version3(parameters);\n    return version4(parameters);\n}\nfunction version4(parameters) {\n    let walletProvider;\n    let accountsChanged;\n    let chainChanged;\n    let disconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((config) => ({\n        id: 'coinbaseWalletSDK',\n        name: 'Coinbase Wallet',\n        rdns: 'com.coinbase.wallet',\n        type: coinbaseWallet.type,\n        async connect({ chainId, withCapabilities, ...rest } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                    params: 'instantOnboarding' in rest && rest.instantOnboarding\n                        ? [{ onboarding: 'instant' }]\n                        : [],\n                })).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return {\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            provider.disconnect();\n            provider.close?.();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return (await provider.request({\n                method: 'eth_accounts',\n            })).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = (await provider.request({\n                method: 'eth_chainId',\n            }));\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                const preference = (() => {\n                    if (typeof parameters.preference === 'string')\n                        return { options: parameters.preference };\n                    return {\n                        ...parameters.preference,\n                        options: parameters.preference?.options ?? 'all',\n                    };\n                })();\n                const { createCoinbaseWalletSDK } = await __webpack_require__.e(/*! import() */ \"node_modules_coinbase_wallet-sdk_dist_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @coinbase/wallet-sdk */ \"../node_modules/@coinbase/wallet-sdk/dist/index.js\"));\n                const sdk = createCoinbaseWalletSDK({\n                    ...parameters,\n                    appChainIds: config.chains.map((x) => x.id),\n                    preference,\n                });\n                walletProvider = sdk.getProvider();\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chain.id) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                // Indicates chain is not added to provider\n                if (error.code === 4902) {\n                    try {\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else\n                            blockExplorerUrls = chain.blockExplorers?.default.url\n                                ? [chain.blockExplorers?.default.url]\n                                : [];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [addEthereumChain],\n                        });\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                    }\n                }\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect(_error) {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n        },\n    }));\n}\nfunction version3(parameters) {\n    const reloadOnDisconnect = false;\n    let sdk;\n    let walletProvider;\n    let accountsChanged;\n    let chainChanged;\n    let disconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((config) => ({\n        id: 'coinbaseWalletSDK',\n        name: 'Coinbase Wallet',\n        rdns: 'com.coinbase.wallet',\n        type: coinbaseWallet.type,\n        async connect({ chainId, withCapabilities } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                })).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return {\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            provider.disconnect();\n            provider.close();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return (await provider.request({\n                method: 'eth_accounts',\n            })).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = await provider.request({\n                method: 'eth_chainId',\n            });\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                // Unwrapping import for Vite compatibility.\n                // See: https://github.com/vitejs/vite/issues/9703\n                const CoinbaseWalletSDK = await (async () => {\n                    const { default: SDK } = await __webpack_require__.e(/*! import() */ \"node_modules_cbw-sdk_dist_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! cbw-sdk */ \"../node_modules/cbw-sdk/dist/index.js\", 19));\n                    if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n                        return SDK.default;\n                    return SDK;\n                })();\n                sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });\n                // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n                const walletExtensionChainId = sdk.walletExtension?.getChainId();\n                const chain = config.chains.find((chain) => parameters.chainId\n                    ? chain.id === parameters.chainId\n                    : chain.id === walletExtensionChainId) || config.chains[0];\n                const chainId = parameters.chainId || chain?.id;\n                const jsonRpcUrl = parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0];\n                walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chain.id) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                // Indicates chain is not added to provider\n                if (error.code === 4902) {\n                    try {\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else\n                            blockExplorerUrls = chain.blockExplorers?.default.url\n                                ? [chain.blockExplorers?.default.url]\n                                : [];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [addEthereumChain],\n                        });\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                    }\n                }\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect(_error) {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n        },\n    }));\n}\n//# sourceMappingURL=coinbaseWallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9jb2luYmFzZVdhbGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0U7QUFDb0I7QUFDNUY7QUFDTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUMsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBLGlCQUFpQixjQUFjLGdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFLDJDQUEyQywwREFBd0I7QUFDbkU7QUFDQSxpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQXdCO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWMsZ0RBQVU7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QiwwQkFBMEIsUUFBUSw2TkFBOEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFnQixLQUFLLGdFQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLGlEQUFXLFlBQVk7QUFDL0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBd0I7QUFDMUQ7QUFDQTtBQUNBLDBCQUEwQixrREFBZ0I7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnREFBVTtBQUM1RCxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEIsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjLGdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFLDJDQUEyQywwREFBd0I7QUFDbkU7QUFDQSxpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQXdCO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWMsZ0RBQVU7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxRQUFRLDZMQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBLDBCQUEwQixrREFBZ0IsS0FBSyxnRUFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxpREFBVyxZQUFZO0FBQy9ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMERBQXdCO0FBQzFEO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWdCO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0RBQVU7QUFDNUQsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9jb2luYmFzZVdhbGxldC5qcz85NTY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYWluTm90Q29uZmlndXJlZEVycm9yLCBjcmVhdGVDb25uZWN0b3IsIH0gZnJvbSAnQHdhZ21pL2NvcmUnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgbnVtYmVyVG9IZXgsIFN3aXRjaENoYWluRXJyb3IsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgfSBmcm9tICd2aWVtJztcbmNvaW5iYXNlV2FsbGV0LnR5cGUgPSAnY29pbmJhc2VXYWxsZXQnO1xuZXhwb3J0IGZ1bmN0aW9uIGNvaW5iYXNlV2FsbGV0KHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIGlmIChwYXJhbWV0ZXJzLnZlcnNpb24gPT09ICczJyB8fCBwYXJhbWV0ZXJzLmhlYWRsZXNzTW9kZSlcbiAgICAgICAgcmV0dXJuIHZlcnNpb24zKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiB2ZXJzaW9uNChwYXJhbWV0ZXJzKTtcbn1cbmZ1bmN0aW9uIHZlcnNpb240KHBhcmFtZXRlcnMpIHtcbiAgICBsZXQgd2FsbGV0UHJvdmlkZXI7XG4gICAgbGV0IGFjY291bnRzQ2hhbmdlZDtcbiAgICBsZXQgY2hhaW5DaGFuZ2VkO1xuICAgIGxldCBkaXNjb25uZWN0O1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3IoKGNvbmZpZykgPT4gKHtcbiAgICAgICAgaWQ6ICdjb2luYmFzZVdhbGxldFNESycsXG4gICAgICAgIG5hbWU6ICdDb2luYmFzZSBXYWxsZXQnLFxuICAgICAgICByZG5zOiAnY29tLmNvaW5iYXNlLndhbGxldCcsXG4gICAgICAgIHR5cGU6IGNvaW5iYXNlV2FsbGV0LnR5cGUsXG4gICAgICAgIGFzeW5jIGNvbm5lY3QoeyBjaGFpbklkLCB3aXRoQ2FwYWJpbGl0aWVzLCAuLi5yZXN0IH0gPSB7fSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogJ2luc3RhbnRPbmJvYXJkaW5nJyBpbiByZXN0ICYmIHJlc3QuaW5zdGFudE9uYm9hcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW3sgb25ib2FyZGluZzogJ2luc3RhbnQnIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgICAgIH0pKS5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHRoaXMub25DaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3dpdGNoIHRvIGNoYWluIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgJiYgY3VycmVudENoYWluSWQgIT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBhd2FpdCB0aGlzLnN3aXRjaENoYWluKHsgY2hhaW5JZCB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiBjdXJyZW50Q2hhaW5JZCB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluSWQgPSBjaGFpbj8uaWQgPz8gY3VycmVudENoYWluSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiAod2l0aENhcGFiaWxpdGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhY2NvdW50cy5tYXAoKGFkZHJlc3MpID0+ICh7IGFkZHJlc3MsIGNhcGFiaWxpdGllczoge30gfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFjY291bnRzKSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY3VycmVudENoYWluSWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICgvKHVzZXIgY2xvc2VkIG1vZGFsfGFjY291bnRzIHJlY2VpdmVkIGlzIGVtcHR5fHVzZXIgZGVuaWVkIGFjY291bnR8cmVxdWVzdCByZWplY3RlZCkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmNsb3NlPy4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2FjY291bnRzJyxcbiAgICAgICAgICAgIH0pKS5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoY2hhaW5JZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFByb3ZpZGVyKCkge1xuICAgICAgICAgICAgaWYgKCF3YWxsZXRQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMucHJlZmVyZW5jZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBvcHRpb25zOiBwYXJhbWV0ZXJzLnByZWZlcmVuY2UgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMucHJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHBhcmFtZXRlcnMucHJlZmVyZW5jZT8ub3B0aW9ucyA/PyAnYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlQ29pbmJhc2VXYWxsZXRTREsgfSA9IGF3YWl0IGltcG9ydCgnQGNvaW5iYXNlL3dhbGxldC1zZGsnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZGsgPSBjcmVhdGVDb2luYmFzZVdhbGxldFNESyh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGFwcENoYWluSWRzOiBjb25maWcuY2hhaW5zLm1hcCgoeCkgPT4geC5pZCksXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXIgPSBzZGsuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3YWxsZXRQcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgaXNBdXRob3JpemVkKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFhY2NvdW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzd2l0Y2hDaGFpbih7IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIsIGNoYWluSWQgfSkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBjb25maWcuY2hhaW5zLmZpbmQoKGNoYWluKSA9PiBjaGFpbi5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluLmlkKSB9XSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgY2hhaW4gaXMgbm90IGFkZGVkIHRvIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQ5MDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9ja0V4cGxvcmVyVXJscztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5ibG9ja0V4cGxvcmVyVXJscylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyA9IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIuYmxvY2tFeHBsb3JlclVybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHMgPSBjaGFpbi5ibG9ja0V4cGxvcmVycz8uZGVmYXVsdC51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ucnBjVXJscz8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMgPSBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLnJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyA9IFtjaGFpbi5ycGNVcmxzLmRlZmF1bHQ/Lmh0dHBbMF0gPz8gJyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkRXRoZXJldW1DaGFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmNoYWluTmFtZSA/PyBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25VcmxzOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5pY29uVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ubmF0aXZlQ3VycmVuY3kgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4ubmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbYWRkRXRoZXJldW1DaGFpbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYWluQ2hhbmdlZChjaGFpbikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihjaGFpbik7XG4gICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7IGNoYWluSWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdChfZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5mdW5jdGlvbiB2ZXJzaW9uMyhwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgcmVsb2FkT25EaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgbGV0IHNkaztcbiAgICBsZXQgd2FsbGV0UHJvdmlkZXI7XG4gICAgbGV0IGFjY291bnRzQ2hhbmdlZDtcbiAgICBsZXQgY2hhaW5DaGFuZ2VkO1xuICAgIGxldCBkaXNjb25uZWN0O1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3IoKGNvbmZpZykgPT4gKHtcbiAgICAgICAgaWQ6ICdjb2luYmFzZVdhbGxldFNESycsXG4gICAgICAgIG5hbWU6ICdDb2luYmFzZSBXYWxsZXQnLFxuICAgICAgICByZG5zOiAnY29tLmNvaW5iYXNlLndhbGxldCcsXG4gICAgICAgIHR5cGU6IGNvaW5iYXNlV2FsbGV0LnR5cGUsXG4gICAgICAgIGFzeW5jIGNvbm5lY3QoeyBjaGFpbklkLCB3aXRoQ2FwYWJpbGl0aWVzIH0gPSB7fSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgfSkpLm1hcCgoeCkgPT4gZ2V0QWRkcmVzcyh4KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNDaGFuZ2VkID0gdGhpcy5vbkFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gY2hhaW4gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudENoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCAmJiBjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IGF3YWl0IHRoaXMuc3dpdGNoQ2hhaW4oeyBjaGFpbklkIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGN1cnJlbnRDaGFpbklkIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW5JZCA9IGNoYWluPy5pZCA/PyBjdXJyZW50Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHM6ICh3aXRoQ2FwYWJpbGl0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gKHsgYWRkcmVzcywgY2FwYWJpbGl0aWVzOiB7fSB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYWNjb3VudHMpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKC8odXNlciBjbG9zZWQgbW9kYWx8YWNjb3VudHMgcmVjZWl2ZWQgaXMgZW1wdHl8dXNlciBkZW5pZWQgYWNjb3VudCkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldEFjY291bnRzKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9hY2NvdW50cycsXG4gICAgICAgICAgICB9KSkubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihjaGFpbklkKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0UHJvdmlkZXIoKSB7XG4gICAgICAgICAgICBpZiAoIXdhbGxldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gVW53cmFwcGluZyBpbXBvcnQgZm9yIFZpdGUgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvOTcwM1xuICAgICAgICAgICAgICAgIGNvbnN0IENvaW5iYXNlV2FsbGV0U0RLID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBTREsgfSA9IGF3YWl0IGltcG9ydCgnY2J3LXNkaycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFNESyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU0RLLmRlZmF1bHQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU0RLLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTREs7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBzZGsgPSBuZXcgQ29pbmJhc2VXYWxsZXRTREsoeyAuLi5wYXJhbWV0ZXJzLCByZWxvYWRPbkRpc2Nvbm5lY3QgfSk7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgdHlwZXMgdG8gcmV0cmlldmUgcHJpdmF0ZSBgd2FsbGV0RXh0ZW5zaW9uYCBtZXRob2QgZnJvbSB0aGUgQ29pbmJhc2UgV2FsbGV0IFNESy5cbiAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXRFeHRlbnNpb25DaGFpbklkID0gc2RrLndhbGxldEV4dGVuc2lvbj8uZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluID0gY29uZmlnLmNoYWlucy5maW5kKChjaGFpbikgPT4gcGFyYW1ldGVycy5jaGFpbklkXG4gICAgICAgICAgICAgICAgICAgID8gY2hhaW4uaWQgPT09IHBhcmFtZXRlcnMuY2hhaW5JZFxuICAgICAgICAgICAgICAgICAgICA6IGNoYWluLmlkID09PSB3YWxsZXRFeHRlbnNpb25DaGFpbklkKSB8fCBjb25maWcuY2hhaW5zWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBwYXJhbWV0ZXJzLmNoYWluSWQgfHwgY2hhaW4/LmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25ScGNVcmwgPSBwYXJhbWV0ZXJzLmpzb25ScGNVcmwgfHwgY2hhaW4/LnJwY1VybHMuZGVmYXVsdC5odHRwWzBdO1xuICAgICAgICAgICAgICAgIHdhbGxldFByb3ZpZGVyID0gc2RrLm1ha2VXZWIzUHJvdmlkZXIoanNvblJwY1VybCwgY2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2FsbGV0UHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGlzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhYWNjb3VudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc3dpdGNoQ2hhaW4oeyBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLCBjaGFpbklkIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gY29uZmlnLmNoYWlucy5maW5kKChjaGFpbikgPT4gY2hhaW4uaWQgPT09IGNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKCFjaGFpbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3dpdGNoQ2hhaW5FcnJvcihuZXcgQ2hhaW5Ob3RDb25maWd1cmVkRXJyb3IoKSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbi5pZCkgfV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5kaWNhdGVzIGNoYWluIGlzIG5vdCBhZGRlZCB0byBwcm92aWRlclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0OTAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tFeHBsb3JlclVybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8uYmxvY2tFeHBsb3JlclVybHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHMgPSBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLmJsb2NrRXhwbG9yZXJVcmxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzID0gY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW2NoYWluLmJsb2NrRXhwbG9yZXJzPy5kZWZhdWx0LnVybF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBycGNVcmxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LnJwY1VybHM/Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzID0gYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlci5ycGNVcmxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMgPSBbY2hhaW4ucnBjVXJscy5kZWZhdWx0Py5odHRwWzBdID8/ICcnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZEV0aGVyZXVtQ2hhaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogbnVtYmVyVG9IZXgoY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5jaGFpbk5hbWUgPz8gY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uVXJsczogYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8uaWNvblVybHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3k6IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/Lm5hdGl2ZUN1cnJlbmN5ID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLm5hdGl2ZUN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FkZEV0aGVyZXVtQ2hhaW5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3dpdGNoQ2hhaW5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHMubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFpbkNoYW5nZWQoY2hhaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIoY2hhaW4pO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgeyBjaGFpbklkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBvbkRpc2Nvbm5lY3QoX2Vycm9yKSB7XG4gICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmIChhY2NvdW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50c0NoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29pbmJhc2VXYWxsZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/exports/index.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/exports/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   baseAccount: function() { return /* reexport safe */ _baseAccount_js__WEBPACK_IMPORTED_MODULE_1__.baseAccount; },\n/* harmony export */   coinbaseWallet: function() { return /* reexport safe */ _coinbaseWallet_js__WEBPACK_IMPORTED_MODULE_2__.coinbaseWallet; },\n/* harmony export */   gemini: function() { return /* reexport safe */ _gemini_js__WEBPACK_IMPORTED_MODULE_3__.gemini; },\n/* harmony export */   injected: function() { return /* reexport safe */ _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.injected; },\n/* harmony export */   metaMask: function() { return /* reexport safe */ _metaMask_js__WEBPACK_IMPORTED_MODULE_4__.metaMask; },\n/* harmony export */   mock: function() { return /* reexport safe */ _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.mock; },\n/* harmony export */   porto: function() { return /* reexport safe */ _porto_js__WEBPACK_IMPORTED_MODULE_5__.porto; },\n/* harmony export */   safe: function() { return /* reexport safe */ _safe_js__WEBPACK_IMPORTED_MODULE_6__.safe; },\n/* harmony export */   version: function() { return /* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_7__.version; },\n/* harmony export */   walletConnect: function() { return /* reexport safe */ _walletConnect_js__WEBPACK_IMPORTED_MODULE_8__.walletConnect; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var _baseAccount_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../baseAccount.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/baseAccount.js\");\n/* harmony import */ var _coinbaseWallet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coinbaseWallet.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js\");\n/* harmony import */ var _gemini_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gemini.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/gemini.js\");\n/* harmony import */ var _metaMask_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../metaMask.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/metaMask.js\");\n/* harmony import */ var _porto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../porto.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/porto.js\");\n/* harmony import */ var _safe_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../safe.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/safe.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../version.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/version.js\");\n/* harmony import */ var _walletConnect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../walletConnect.js */ \"../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/walletConnect.js\");\n// biome-ignore lint/performance/noBarrelFile: entrypoint module\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9leHBvcnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNFO0FBQ087QUFDakI7QUFDSTtBQUNOO0FBQ0Y7QUFDTTtBQUNhO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvd2FnbWkvbm9kZV9tb2R1bGVzL0B3YWdtaS9jb25uZWN0b3JzL2Rpc3QvZXNtL2V4cG9ydHMvaW5kZXguanM/YWI4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBiaW9tZS1pZ25vcmUgbGludC9wZXJmb3JtYW5jZS9ub0JhcnJlbEZpbGU6IGVudHJ5cG9pbnQgbW9kdWxlXG5leHBvcnQgeyBpbmplY3RlZCwgbW9jaywgfSBmcm9tICdAd2FnbWkvY29yZSc7XG5leHBvcnQgeyBiYXNlQWNjb3VudCB9IGZyb20gJy4uL2Jhc2VBY2NvdW50LmpzJztcbmV4cG9ydCB7IGNvaW5iYXNlV2FsbGV0LCB9IGZyb20gJy4uL2NvaW5iYXNlV2FsbGV0LmpzJztcbmV4cG9ydCB7IGdlbWluaSB9IGZyb20gJy4uL2dlbWluaS5qcyc7XG5leHBvcnQgeyBtZXRhTWFzayB9IGZyb20gJy4uL21ldGFNYXNrLmpzJztcbmV4cG9ydCB7IHBvcnRvIH0gZnJvbSAnLi4vcG9ydG8uanMnO1xuZXhwb3J0IHsgc2FmZSB9IGZyb20gJy4uL3NhZmUuanMnO1xuZXhwb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24uanMnO1xuZXhwb3J0IHsgd2FsbGV0Q29ubmVjdCwgfSBmcm9tICcuLi93YWxsZXRDb25uZWN0LmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/exports/index.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/gemini.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/gemini.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gemini: function() { return /* binding */ gemini; }\n/* harmony export */ });\n/* harmony import */ var _gemini_wallet_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @gemini-wallet/core */ \"../node_modules/wagmi/node_modules/@gemini-wallet/core/dist/index.js\");\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\n\ngemini.type = 'gemini';\nfunction gemini(parameters = {}) {\n    let walletProvider;\n    let onAccountsChanged;\n    let onChainChanged;\n    let onDisconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_1__.createConnector)((config) => ({\n        id: 'gemini',\n        name: 'Gemini Wallet',\n        type: gemini.type,\n        icon: 'https://keys.gemini.com/images/gemini-wallet-logo.svg',\n        async connect({ chainId, withCapabilities } = {}) {\n            try {\n                const provider = await this.getProvider();\n                const accounts = (await provider.request({\n                    method: 'eth_requestAccounts',\n                }));\n                if (!onAccountsChanged) {\n                    onAccountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', onAccountsChanged);\n                }\n                if (!onChainChanged) {\n                    onChainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', onChainChanged);\n                }\n                if (!onDisconnect) {\n                    onDisconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', onDisconnect);\n                }\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_2__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                return {\n                    // TODO(v3): Make `withCapabilities: true` default behavior\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (error) {\n                if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))\n                    throw new viem__WEBPACK_IMPORTED_MODULE_2__.UserRejectedRequestError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (onAccountsChanged) {\n                provider.removeListener('accountsChanged', onAccountsChanged);\n                onAccountsChanged = undefined;\n            }\n            if (onChainChanged) {\n                provider.removeListener('chainChanged', onChainChanged);\n                onChainChanged = undefined;\n            }\n            if (onDisconnect) {\n                provider.removeListener('disconnect', onDisconnect);\n                onDisconnect = undefined;\n            }\n            await provider.disconnect();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            const accounts = (await provider.request({\n                method: 'eth_accounts',\n            }));\n            return accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_2__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = (await provider.request({\n                method: 'eth_chainId',\n            }));\n            return Number(chainId);\n        },\n        async getProvider() {\n            if (!walletProvider) {\n                walletProvider = new _gemini_wallet_core__WEBPACK_IMPORTED_MODULE_0__.GeminiWalletProvider({\n                    appMetadata: parameters.appMetadata ?? {},\n                    chain: {\n                        id: config.chains[0]?.id ?? 1,\n                        rpcUrl: config.chains[0]?.rpcUrls?.default?.http[0],\n                    },\n                });\n            }\n            return walletProvider;\n        },\n        async isAuthorized() {\n            try {\n                const accounts = await this.getAccounts();\n                return Boolean(accounts.length);\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ chainId }) {\n            const chain = config.chains.find((chain) => chain.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_2__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_1__.ChainNotConfiguredError());\n            const provider = await this.getProvider();\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_2__.numberToHex)(chainId) }],\n                });\n                return chain;\n            }\n            catch (error) {\n                throw new viem__WEBPACK_IMPORTED_MODULE_2__.SwitchChainError(error);\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_2__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onDisconnect() {\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (onAccountsChanged) {\n                provider.removeListener('accountsChanged', onAccountsChanged);\n                onAccountsChanged = undefined;\n            }\n            if (onChainChanged) {\n                provider.removeListener('chainChanged', onChainChanged);\n                onChainChanged = undefined;\n            }\n            if (onDisconnect) {\n                provider.removeListener('disconnect', onDisconnect);\n                onDisconnect = undefined;\n            }\n        },\n    }));\n}\n//# sourceMappingURL=gemini.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9nZW1pbmkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyRDtBQUNhO0FBQ29CO0FBQzVGO0FBQ08sK0JBQStCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEIsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEUsMkNBQTJDLDBEQUF3QjtBQUNuRTtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUF3QjtBQUN0RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1Q0FBdUMsZ0RBQVU7QUFDakQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUMscUVBQW9CO0FBQ3pELDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0EsMEJBQTBCLGtEQUFnQixLQUFLLGdFQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLGlEQUFXLFdBQVc7QUFDOUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBZ0I7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnREFBVTtBQUM1RCxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvd2FnbWkvbm9kZV9tb2R1bGVzL0B3YWdtaS9jb25uZWN0b3JzL2Rpc3QvZXNtL2dlbWluaS5qcz82NmFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdlbWluaVdhbGxldFByb3ZpZGVyIH0gZnJvbSAnQGdlbWluaS13YWxsZXQvY29yZSc7XG5pbXBvcnQgeyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvciwgY3JlYXRlQ29ubmVjdG9yLCB9IGZyb20gJ0B3YWdtaS9jb3JlJztcbmltcG9ydCB7IGdldEFkZHJlc3MsIG51bWJlclRvSGV4LCBTd2l0Y2hDaGFpbkVycm9yLCBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsIH0gZnJvbSAndmllbSc7XG5nZW1pbmkudHlwZSA9ICdnZW1pbmknO1xuZXhwb3J0IGZ1bmN0aW9uIGdlbWluaShwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBsZXQgd2FsbGV0UHJvdmlkZXI7XG4gICAgbGV0IG9uQWNjb3VudHNDaGFuZ2VkO1xuICAgIGxldCBvbkNoYWluQ2hhbmdlZDtcbiAgICBsZXQgb25EaXNjb25uZWN0O1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3IoKGNvbmZpZykgPT4gKHtcbiAgICAgICAgaWQ6ICdnZW1pbmknLFxuICAgICAgICBuYW1lOiAnR2VtaW5pIFdhbGxldCcsXG4gICAgICAgIHR5cGU6IGdlbWluaS50eXBlLFxuICAgICAgICBpY29uOiAnaHR0cHM6Ly9rZXlzLmdlbWluaS5jb20vaW1hZ2VzL2dlbWluaS13YWxsZXQtbG9nby5zdmcnLFxuICAgICAgICBhc3luYyBjb25uZWN0KHsgY2hhaW5JZCwgd2l0aENhcGFiaWxpdGllcyB9ID0ge30pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9uQWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQWNjb3VudHNDaGFuZ2VkID0gdGhpcy5vbkFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgb25BY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9uQ2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhaW5DaGFuZ2VkID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgb25DaGFpbkNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9uRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzY29ubmVjdCcsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbklkICYmIGN1cnJlbnRDaGFpbklkICE9PSBjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluID0gYXdhaXQgdGhpcy5zd2l0Y2hDaGFpbih7IGNoYWluSWQgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZDogY3VycmVudENoYWluSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFpbklkID0gY2hhaW4/LmlkID8/IGN1cnJlbnRDaGFpbklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHYzKTogTWFrZSBgd2l0aENhcGFiaWxpdGllczogdHJ1ZWAgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogKHdpdGhDYXBhYmlsaXRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWNjb3VudHMubWFwKChhZGRyZXNzKSA9PiAoeyBhZGRyZXNzLCBjYXBhYmlsaXRpZXM6IHt9IH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhY2NvdW50cyksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoLyh1c2VyIGNsb3NlZCBtb2RhbHxhY2NvdW50cyByZWNlaXZlZCBpcyBlbXB0eXx1c2VyIGRlbmllZCBhY2NvdW50fHJlcXVlc3QgcmVqZWN0ZWQpL2kudGVzdChlcnJvci5tZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmIChvbkFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBvbkFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgb25BY2NvdW50c0NoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25DaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgb25DaGFpbkNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIG9uQ2hhaW5DaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0Jywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICBvbkRpc2Nvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBwcm92aWRlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldEFjY291bnRzKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfYWNjb3VudHMnLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoeCkgPT4gZ2V0QWRkcmVzcyh4KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihjaGFpbklkKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0UHJvdmlkZXIoKSB7XG4gICAgICAgICAgICBpZiAoIXdhbGxldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXIgPSBuZXcgR2VtaW5pV2FsbGV0UHJvdmlkZXIoe1xuICAgICAgICAgICAgICAgICAgICBhcHBNZXRhZGF0YTogcGFyYW1ldGVycy5hcHBNZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjb25maWcuY2hhaW5zWzBdPy5pZCA/PyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJsOiBjb25maWcuY2hhaW5zWzBdPy5ycGNVcmxzPy5kZWZhdWx0Py5odHRwWzBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhbGxldFByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBpc0F1dGhvcml6ZWQoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGFjY291bnRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzd2l0Y2hDaGFpbih7IGNoYWluSWQgfSkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBjb25maWcuY2hhaW5zLmZpbmQoKGNoYWluKSA9PiBjaGFpbi5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluSWQpIH1dLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYWluQ2hhbmdlZChjaGFpbikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihjaGFpbik7XG4gICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7IGNoYWluSWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKG9uQWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2FjY291bnRzQ2hhbmdlZCcsIG9uQWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBvbkFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNoYWluQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdjaGFpbkNoYW5nZWQnLCBvbkNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgb25DaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25EaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW1pbmkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/gemini.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/metaMask.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/metaMask.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   metaMask: function() { return /* binding */ metaMask; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\nmetaMask.type = 'metaMask';\nfunction metaMask(parameters = {}) {\n    let sdk;\n    let provider;\n    let providerPromise;\n    let accountsChanged;\n    let chainChanged;\n    let connect;\n    let displayUri;\n    let disconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((config) => ({\n        id: 'metaMaskSDK',\n        name: 'MetaMask',\n        rdns: ['io.metamask', 'io.metamask.mobile'],\n        type: metaMask.type,\n        async setup() {\n            const provider = await this.getProvider();\n            if (provider?.on) {\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n                // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n                // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n            }\n        },\n        async connect({ chainId, isReconnecting, withCapabilities } = {}) {\n            const provider = await this.getProvider();\n            if (!displayUri) {\n                displayUri = this.onDisplayUri;\n                provider.on('display_uri', displayUri);\n            }\n            let accounts = [];\n            if (isReconnecting)\n                accounts = await this.getAccounts().catch(() => []);\n            try {\n                let signResponse;\n                let connectWithResponse;\n                if (!accounts?.length) {\n                    if (parameters.connectAndSign || parameters.connectWith) {\n                        if (parameters.connectAndSign)\n                            signResponse = await sdk.connectAndSign({\n                                msg: parameters.connectAndSign,\n                            });\n                        else if (parameters.connectWith)\n                            connectWithResponse = await sdk.connectWith({\n                                method: parameters.connectWith.method,\n                                params: parameters.connectWith.params,\n                            });\n                        accounts = await this.getAccounts();\n                    }\n                    else {\n                        const requestedAccounts = (await sdk.connect());\n                        accounts = requestedAccounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                    }\n                }\n                // Switch to chain if provided\n                let currentChainId = (await this.getChainId());\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                if (displayUri) {\n                    provider.removeListener('display_uri', displayUri);\n                    displayUri = undefined;\n                }\n                if (signResponse)\n                    provider.emit('connectAndSign', {\n                        accounts,\n                        chainId: currentChainId,\n                        signResponse,\n                    });\n                else if (connectWithResponse)\n                    provider.emit('connectWith', {\n                        accounts,\n                        chainId: currentChainId,\n                        connectWithResponse,\n                    });\n                // Manage EIP-1193 event listeners\n                // https://eips.ethereum.org/EIPS/eip-1193#events\n                if (connect) {\n                    provider.removeListener('connect', connect);\n                    connect = undefined;\n                }\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                return {\n                    // TODO(v3): Make `withCapabilities: true` default behavior\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (err) {\n                const error = err;\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.ResourceUnavailableRpcError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.ResourceUnavailableRpcError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            // Manage EIP-1193 event listeners\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            if (!connect) {\n                connect = this.onConnect.bind(this);\n                provider.on('connect', connect);\n            }\n            await sdk.terminate();\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            const accounts = (await provider.request({\n                method: 'eth_accounts',\n            }));\n            return accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            const chainId = provider.getChainId() ||\n                (await provider?.request({ method: 'eth_chainId' }));\n            return Number(chainId);\n        },\n        async getProvider() {\n            async function initProvider() {\n                // Unwrapping import for Vite compatibility.\n                // See: https://github.com/vitejs/vite/issues/9703\n                const MetaMaskSDK = await (async () => {\n                    const { default: SDK } = await __webpack_require__.e(/*! import() */ \"node_modules_metamask_sdk_dist_browser_es_metamask-sdk_js\").then(__webpack_require__.bind(__webpack_require__, /*! @metamask/sdk */ \"../node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js\"));\n                    if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n                        return SDK.default;\n                    return SDK;\n                })();\n                const readonlyRPCMap = {};\n                for (const chain of config.chains)\n                    readonlyRPCMap[(0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chain.id)] = (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.extractRpcUrls)({\n                        chain,\n                        transports: config.transports,\n                    })?.[0];\n                sdk = new MetaMaskSDK({\n                    _source: 'wagmi',\n                    forceDeleteProvider: false,\n                    forceInjectProvider: false,\n                    injectProvider: false,\n                    // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`\n                    ...parameters,\n                    readonlyRPCMap,\n                    dappMetadata: {\n                        ...parameters.dappMetadata,\n                        // Test if name and url are set AND not empty\n                        name: parameters.dappMetadata?.name\n                            ? parameters.dappMetadata?.name\n                            : 'wagmi',\n                        url: parameters.dappMetadata?.url\n                            ? parameters.dappMetadata?.url\n                            : typeof window !== 'undefined'\n                                ? window.location.origin\n                                : 'https://wagmi.sh',\n                    },\n                    useDeeplink: parameters.useDeeplink ?? true,\n                });\n                const result = await sdk.init();\n                // On initial load, sometimes `sdk.getProvider` does not return provider.\n                // https://github.com/wevm/wagmi/issues/4367\n                // Use result of `init` call if available.\n                const provider = (() => {\n                    if (result?.activeProvider)\n                        return result.activeProvider;\n                    return sdk.getProvider();\n                })();\n                if (!provider)\n                    throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n                return provider;\n            }\n            if (!provider) {\n                if (!providerPromise)\n                    providerPromise = initProvider();\n                provider = await providerPromise;\n            }\n            return provider;\n        },\n        async isAuthorized() {\n            try {\n                // MetaMask mobile provider sometimes fails to immediately resolve\n                // JSON-RPC requests on page load\n                const timeout = 200;\n                const accounts = await (0,viem__WEBPACK_IMPORTED_MODULE_1__.withRetry)(() => (0,viem__WEBPACK_IMPORTED_MODULE_1__.withTimeout)(() => this.getAccounts(), { timeout }), {\n                    delay: timeout + 1,\n                    retryCount: 3,\n                });\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const provider = await this.getProvider();\n            const chain = config.chains.find((x) => x.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError());\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId) }],\n                });\n                // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n                // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n                // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n                // this callback or an externally emitted `'chainChanged'` event.\n                // https://github.com/MetaMask/metamask-extension/issues/24247\n                await waitForChainIdToSync();\n                await sendAndWaitForChangeEvent(chainId);\n                return chain;\n            }\n            catch (err) {\n                const error = err;\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                // Indicates chain is not added to provider\n                if (error.code === 4902 ||\n                    // Unwrapping for MetaMask Mobile\n                    // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n                    error\n                        ?.data?.originalError?.code === 4902) {\n                    try {\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [\n                                {\n                                    blockExplorerUrls: (() => {\n                                        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};\n                                        if (addEthereumChainParameter?.blockExplorerUrls)\n                                            return addEthereumChainParameter.blockExplorerUrls;\n                                        if (blockExplorer)\n                                            return [\n                                                blockExplorer.url,\n                                                ...Object.values(blockExplorers).map((x) => x.url),\n                                            ];\n                                        return;\n                                    })(),\n                                    chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId),\n                                    chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                                    iconUrls: addEthereumChainParameter?.iconUrls,\n                                    nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                        chain.nativeCurrency,\n                                    rpcUrls: (() => {\n                                        if (addEthereumChainParameter?.rpcUrls?.length)\n                                            return addEthereumChainParameter.rpcUrls;\n                                        return [chain.rpcUrls.default?.http[0] ?? ''];\n                                    })(),\n                                },\n                            ],\n                        });\n                        await waitForChainIdToSync();\n                        await sendAndWaitForChangeEvent(chainId);\n                        return chain;\n                    }\n                    catch (err) {\n                        const error = err;\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                            throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                        throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(error);\n                    }\n                }\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(error);\n            }\n            async function waitForChainIdToSync() {\n                // On mobile, there is a race condition between the result of `'wallet_addEthereumChain'` and `'eth_chainId'`.\n                // To avoid this, we wait for `'eth_chainId'` to return the expected chain ID with a retry loop.\n                await (0,viem__WEBPACK_IMPORTED_MODULE_1__.withRetry)(async () => {\n                    const value = (0,viem__WEBPACK_IMPORTED_MODULE_1__.hexToNumber)(\n                    // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks\n                    (await provider.request({ method: 'eth_chainId' })));\n                    // `value` doesn't match expected `chainId`, throw to trigger retry\n                    if (value !== chainId)\n                        throw new Error('User rejected switch after adding network.');\n                    return value;\n                }, {\n                    delay: 50,\n                    retryCount: 20, // android device encryption is slower\n                });\n            }\n            async function sendAndWaitForChangeEvent(chainId) {\n                await new Promise((resolve) => {\n                    const listener = ((data) => {\n                        if ('chainId' in data && data.chainId === chainId) {\n                            config.emitter.off('change', listener);\n                            resolve();\n                        }\n                    });\n                    config.emitter.on('change', listener);\n                    config.emitter.emit('change', { chainId });\n                });\n            }\n        },\n        async onAccountsChanged(accounts) {\n            // Disconnect if there are no accounts\n            if (accounts.length === 0) {\n                // ... and using browser extension\n                if (sdk.isExtensionActive())\n                    this.onDisconnect();\n                // FIXME(upstream): Mobile app sometimes emits invalid `accountsChanged` event with empty accounts array\n                else\n                    return;\n            }\n            // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n            else if (config.emitter.listenerCount('connect')) {\n                const chainId = (await this.getChainId()).toString();\n                this.onConnect({ chainId });\n            }\n            // Regular change event\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onConnect(connectInfo) {\n            const accounts = await this.getAccounts();\n            if (accounts.length === 0)\n                return;\n            const chainId = Number(connectInfo.chainId);\n            config.emitter.emit('connect', { accounts, chainId });\n            const provider = await this.getProvider();\n            if (connect) {\n                provider.removeListener('connect', connect);\n                connect = undefined;\n            }\n            if (!accountsChanged) {\n                accountsChanged = this.onAccountsChanged.bind(this);\n                provider.on('accountsChanged', accountsChanged);\n            }\n            if (!chainChanged) {\n                chainChanged = this.onChainChanged.bind(this);\n                provider.on('chainChanged', chainChanged);\n            }\n            if (!disconnect) {\n                disconnect = this.onDisconnect.bind(this);\n                provider.on('disconnect', disconnect);\n            }\n        },\n        async onDisconnect(error) {\n            const provider = await this.getProvider();\n            // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n            // https://github.com/MetaMask/providers/pull/120\n            if (error && error.code === 1013) {\n                if (provider && !!(await this.getAccounts()).length)\n                    return;\n            }\n            config.emitter.emit('disconnect');\n            // Manage EIP-1193 event listeners\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            if (!connect) {\n                connect = this.onConnect.bind(this);\n                provider.on('connect', connect);\n            }\n        },\n        onDisplayUri(uri) {\n            config.emitter.emit('message', { type: 'display_uri', data: uri });\n        },\n    }));\n}\n//# sourceMappingURL=metaMask.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9tZXRhTWFzay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0c7QUFDK0M7QUFDOUo7QUFDTyxpQ0FBaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNERBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3Qiw0Q0FBNEMsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnREFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEUsMkNBQTJDLDBEQUF3QjtBQUNuRTtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBEQUF3QjtBQUMzRCw4QkFBOEIsMERBQXdCO0FBQ3RELG1DQUFtQyw2REFBMkI7QUFDOUQsOEJBQThCLDZEQUEyQjtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVDQUF1QyxnREFBVTtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsUUFBUSw0T0FBdUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQVcsY0FBYywyREFBYztBQUMxRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw4QkFBOEIsOERBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQ0FBUyxPQUFPLGlEQUFXLDZCQUE2QixTQUFTO0FBQ3hHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBZ0IsS0FBSyxnRUFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsaURBQVcsV0FBVztBQUM5RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwREFBd0I7QUFDM0QsOEJBQThCLDBEQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNENBQTRDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsNkNBQTZDLGlEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwREFBd0I7QUFDbkUsc0NBQXNDLDBEQUF3QjtBQUM5RCxrQ0FBa0Msa0RBQWdCO0FBQ2xEO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtDQUFTO0FBQy9CLGtDQUFrQyxpREFBVztBQUM3QztBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0RBQVU7QUFDNUQsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9tZXRhTWFzay5qcz8xNDJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYWluTm90Q29uZmlndXJlZEVycm9yLCBjcmVhdGVDb25uZWN0b3IsIGV4dHJhY3RScGNVcmxzLCBQcm92aWRlck5vdEZvdW5kRXJyb3IsIH0gZnJvbSAnQHdhZ21pL2NvcmUnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgaGV4VG9OdW1iZXIsIG51bWJlclRvSGV4LCBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IsIFN3aXRjaENoYWluRXJyb3IsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgd2l0aFJldHJ5LCB3aXRoVGltZW91dCwgfSBmcm9tICd2aWVtJztcbm1ldGFNYXNrLnR5cGUgPSAnbWV0YU1hc2snO1xuZXhwb3J0IGZ1bmN0aW9uIG1ldGFNYXNrKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIGxldCBzZGs7XG4gICAgbGV0IHByb3ZpZGVyO1xuICAgIGxldCBwcm92aWRlclByb21pc2U7XG4gICAgbGV0IGFjY291bnRzQ2hhbmdlZDtcbiAgICBsZXQgY2hhaW5DaGFuZ2VkO1xuICAgIGxldCBjb25uZWN0O1xuICAgIGxldCBkaXNwbGF5VXJpO1xuICAgIGxldCBkaXNjb25uZWN0O1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3IoKGNvbmZpZykgPT4gKHtcbiAgICAgICAgaWQ6ICdtZXRhTWFza1NESycsXG4gICAgICAgIG5hbWU6ICdNZXRhTWFzaycsXG4gICAgICAgIHJkbnM6IFsnaW8ubWV0YW1hc2snLCAnaW8ubWV0YW1hc2subW9iaWxlJ10sXG4gICAgICAgIHR5cGU6IG1ldGFNYXNrLnR5cGUsXG4gICAgICAgIGFzeW5jIHNldHVwKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXI/Lm9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGRuJ3QgbmVlZCB0byBsaXN0ZW4gZm9yIGAnYWNjb3VudHNDaGFuZ2VkJ2AgaGVyZSBzaW5jZSB0aGUgYCdjb25uZWN0J2AgZXZlbnQgc2hvdWxkIHN1ZmZpY2UgKGFuZCB3YWxsZXQgc2hvdWxkbid0IGJlIGNvbm5lY3RlZCB5ZXQpLlxuICAgICAgICAgICAgICAgIC8vIFNvbWUgd2FsbGV0cywgbGlrZSBNZXRhTWFzaywgZG8gbm90IGltcGxlbWVudCB0aGUgYCdjb25uZWN0J2AgZXZlbnQgYW5kIG92ZXJsb2FkIGAnYWNjb3VudHNDaGFuZ2VkJ2AgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50c0NoYW5nZWQgPSB0aGlzLm9uQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY29ubmVjdCh7IGNoYWluSWQsIGlzUmVjb25uZWN0aW5nLCB3aXRoQ2FwYWJpbGl0aWVzIH0gPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAoIWRpc3BsYXlVcmkpIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VXJpID0gdGhpcy5vbkRpc3BsYXlVcmk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc3BsYXlfdXJpJywgZGlzcGxheVVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWNjb3VudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpc1JlY29ubmVjdGluZylcbiAgICAgICAgICAgICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKS5jYXRjaCgoKSA9PiBbXSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBzaWduUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RXaXRoUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmNvbm5lY3RBbmRTaWduIHx8IHBhcmFtZXRlcnMuY29ubmVjdFdpdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmNvbm5lY3RBbmRTaWduKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25SZXNwb25zZSA9IGF3YWl0IHNkay5jb25uZWN0QW5kU2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZzogcGFyYW1ldGVycy5jb25uZWN0QW5kU2lnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtZXRlcnMuY29ubmVjdFdpdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFdpdGhSZXNwb25zZSA9IGF3YWl0IHNkay5jb25uZWN0V2l0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyYW1ldGVycy5jb25uZWN0V2l0aC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1ldGVycy5jb25uZWN0V2l0aC5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZEFjY291bnRzID0gKGF3YWl0IHNkay5jb25uZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMgPSByZXF1ZXN0ZWRBY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCB0byBjaGFpbiBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2hhaW5JZCA9IChhd2FpdCB0aGlzLmdldENoYWluSWQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgJiYgY3VycmVudENoYWluSWQgIT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBhd2FpdCB0aGlzLnN3aXRjaENoYWluKHsgY2hhaW5JZCB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlkOiBjdXJyZW50Q2hhaW5JZCB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluSWQgPSBjaGFpbj8uaWQgPz8gY3VycmVudENoYWluSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5VXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNwbGF5X3VyaScsIGRpc3BsYXlVcmkpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VXJpID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2lnblJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5lbWl0KCdjb25uZWN0QW5kU2lnbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY3VycmVudENoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbm5lY3RXaXRoUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoJ2Nvbm5lY3RXaXRoJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RXaXRoUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMjZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNDaGFuZ2VkID0gdGhpcy5vbkFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHYzKTogTWFrZSBgd2l0aENhcGFiaWxpdGllczogdHJ1ZWAgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogKHdpdGhDYXBhYmlsaXRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWNjb3VudHMubWFwKChhZGRyZXNzKSA9PiAoeyBhZGRyZXNzLCBjYXBhYmlsaXRpZXM6IHt9IH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhY2NvdW50cyksXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gUmVzb3VyY2VVbmF2YWlsYWJsZVJwY0Vycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBNYW5hZ2UgRUlQLTExOTMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAoY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2RrLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2FjY291bnRzJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gcHJvdmlkZXIuZ2V0Q2hhaW5JZCgpIHx8XG4gICAgICAgICAgICAgICAgKGF3YWl0IHByb3ZpZGVyPy5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoY2hhaW5JZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFByb3ZpZGVyKCkge1xuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gaW5pdFByb3ZpZGVyKCkge1xuICAgICAgICAgICAgICAgIC8vIFVud3JhcHBpbmcgaW1wb3J0IGZvciBWaXRlIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzk3MDNcbiAgICAgICAgICAgICAgICBjb25zdCBNZXRhTWFza1NESyA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogU0RLIH0gPSBhd2FpdCBpbXBvcnQoJ0BtZXRhbWFzay9zZGsnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBTREsgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNESy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNESy5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU0RLO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZG9ubHlSUENNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIGNvbmZpZy5jaGFpbnMpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5UlBDTWFwW251bWJlclRvSGV4KGNoYWluLmlkKV0gPSBleHRyYWN0UnBjVXJscyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IGNvbmZpZy50cmFuc3BvcnRzLFxuICAgICAgICAgICAgICAgICAgICB9KT8uWzBdO1xuICAgICAgICAgICAgICAgIHNkayA9IG5ldyBNZXRhTWFza1NESyh7XG4gICAgICAgICAgICAgICAgICAgIF9zb3VyY2U6ICd3YWdtaScsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlRGVsZXRlUHJvdmlkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZUluamVjdFByb3ZpZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvdmlkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGNhc3Qgc2luY2UgTWV0YU1hc2sgU0RLIGRvZXMgbm90IHN1cHBvcnQgYCdleGFjdE9wdGlvbmFsUHJvcGVydHlUeXBlcydgXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5UlBDTWFwLFxuICAgICAgICAgICAgICAgICAgICBkYXBwTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMuZGFwcE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBpZiBuYW1lIGFuZCB1cmwgYXJlIHNldCBBTkQgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbWV0ZXJzLmRhcHBNZXRhZGF0YT8ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyYW1ldGVycy5kYXBwTWV0YWRhdGE/Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICd3YWdtaScsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHBhcmFtZXRlcnMuZGFwcE1ldGFkYXRhPy51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtZXRlcnMuZGFwcE1ldGFkYXRhPy51cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdodHRwczovL3dhZ21pLnNoJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXNlRGVlcGxpbms6IHBhcmFtZXRlcnMudXNlRGVlcGxpbmsgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZGsuaW5pdCgpO1xuICAgICAgICAgICAgICAgIC8vIE9uIGluaXRpYWwgbG9hZCwgc29tZXRpbWVzIGBzZGsuZ2V0UHJvdmlkZXJgIGRvZXMgbm90IHJldHVybiBwcm92aWRlci5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvNDM2N1xuICAgICAgICAgICAgICAgIC8vIFVzZSByZXN1bHQgb2YgYGluaXRgIGNhbGwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdD8uYWN0aXZlUHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmFjdGl2ZVByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2RrLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RGb3VuZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghcHJvdmlkZXJQcm9taXNlKVxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlclByb21pc2UgPSBpbml0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgaXNBdXRob3JpemVkKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBNZXRhTWFzayBtb2JpbGUgcHJvdmlkZXIgc29tZXRpbWVzIGZhaWxzIHRvIGltbWVkaWF0ZWx5IHJlc29sdmVcbiAgICAgICAgICAgICAgICAvLyBKU09OLVJQQyByZXF1ZXN0cyBvbiBwYWdlIGxvYWRcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gMjAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2l0aFJldHJ5KCgpID0+IHdpdGhUaW1lb3V0KCgpID0+IHRoaXMuZ2V0QWNjb3VudHMoKSwgeyB0aW1lb3V0IH0pLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiB0aW1lb3V0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudDogMyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFhY2NvdW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzd2l0Y2hDaGFpbih7IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIsIGNoYWluSWQgfSkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNvbmZpZy5jaGFpbnMuZmluZCgoeCkgPT4geC5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbklkKSB9XSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBEdXJpbmcgYCd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbidgLCBNZXRhTWFzayBtYWtlcyBhIGAnbmV0X3ZlcnNpb24nYCBSUEMgY2FsbCB0byB0aGUgdGFyZ2V0IGNoYWluLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBmYWlscywgTWV0YU1hc2sgZG9lcyBub3QgZW1pdCB0aGUgYCdjaGFpbkNoYW5nZWQnYCBldmVudCwgYnV0IHdpbGwgc3RpbGwgc3dpdGNoIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICAvLyBUbyBjb3VudGVyIHRoaXMgYmVoYXZpb3IsIHdlIHJlcXVlc3QgYW5kIGVtaXQgdGhlIGN1cnJlbnQgY2hhaW4gSUQgdG8gY29uZmlybSB0aGUgY2hhaW4gc3dpdGNoIGVpdGhlciB2aWFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbGxiYWNrIG9yIGFuIGV4dGVybmFsbHkgZW1pdHRlZCBgJ2NoYWluQ2hhbmdlZCdgIGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzI0MjQ3XG4gICAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvckNoYWluSWRUb1N5bmMoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZW5kQW5kV2FpdEZvckNoYW5nZUV2ZW50KGNoYWluSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyBjaGFpbiBpcyBub3QgYWRkZWQgdG8gcHJvdmlkZXJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDkwMiB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBVbndyYXBwaW5nIGZvciBNZXRhTWFzayBNb2JpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLW1vYmlsZS9pc3N1ZXMvMjk0NCNpc3N1ZWNvbW1lbnQtOTc2OTg4NzE5XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/LmRhdGE/Lm9yaWdpbmFsRXJyb3I/LmNvZGUgPT09IDQ5MDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHM6ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBibG9ja0V4cGxvcmVyLCAuLi5ibG9ja0V4cGxvcmVycyB9ID0gY2hhaW4uYmxvY2tFeHBsb3JlcnMgPz8ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmJsb2NrRXhwbG9yZXJVcmxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlci5ibG9ja0V4cGxvcmVyVXJscztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tFeHBsb3JlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhibG9ja0V4cGxvcmVycykubWFwKCh4KSA9PiB4LnVybCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5jaGFpbk5hbWUgPz8gY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25VcmxzOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5pY29uVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5uYXRpdmVDdXJyZW5jeSA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLm5hdGl2ZUN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJsczogKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ucnBjVXJscz8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlci5ycGNVcmxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY2hhaW4ucnBjVXJscy5kZWZhdWx0Py5odHRwWzBdID8/ICcnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvckNoYWluSWRUb1N5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbmRBbmRXYWl0Rm9yQ2hhbmdlRXZlbnQoY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3dpdGNoQ2hhaW5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNoYWluSWRUb1N5bmMoKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gbW9iaWxlLCB0aGVyZSBpcyBhIHJhY2UgY29uZGl0aW9uIGJldHdlZW4gdGhlIHJlc3VsdCBvZiBgJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJ2AgYW5kIGAnZXRoX2NoYWluSWQnYC5cbiAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCB0aGlzLCB3ZSB3YWl0IGZvciBgJ2V0aF9jaGFpbklkJ2AgdG8gcmV0dXJuIHRoZSBleHBlY3RlZCBjaGFpbiBJRCB3aXRoIGEgcmV0cnkgbG9vcC5cbiAgICAgICAgICAgICAgICBhd2FpdCB3aXRoUmV0cnkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhleFRvTnVtYmVyKFxuICAgICAgICAgICAgICAgICAgICAvLyBgJ2V0aF9jaGFpbklkJ2AgaXMgY2FjaGVkIGJ5IHRoZSBNZXRhTWFzayBTREsgc2lkZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBkZWVwbGlua3NcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICdldGhfY2hhaW5JZCcgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHZhbHVlYCBkb2Vzbid0IG1hdGNoIGV4cGVjdGVkIGBjaGFpbklkYCwgdGhyb3cgdG8gdHJpZ2dlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgcmVqZWN0ZWQgc3dpdGNoIGFmdGVyIGFkZGluZyBuZXR3b3JrLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBkZWxheTogNTAsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQ6IDIwLCAvLyBhbmRyb2lkIGRldmljZSBlbmNyeXB0aW9uIGlzIHNsb3dlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gc2VuZEFuZFdhaXRGb3JDaGFuZ2VFdmVudChjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnY2hhaW5JZCcgaW4gZGF0YSAmJiBkYXRhLmNoYWluSWQgPT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5vZmYoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5vbignY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7IGNoYWluSWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKSB7XG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IGlmIHRoZXJlIGFyZSBubyBhY2NvdW50c1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgdXNpbmcgYnJvd3NlciBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBpZiAoc2RrLmlzRXh0ZW5zaW9uQWN0aXZlKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUodXBzdHJlYW0pOiBNb2JpbGUgYXBwIHNvbWV0aW1lcyBlbWl0cyBpbnZhbGlkIGBhY2NvdW50c0NoYW5nZWRgIGV2ZW50IHdpdGggZW1wdHkgYWNjb3VudHMgYXJyYXlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbm5lY3QgaWYgZW1pdHRlciBpcyBsaXN0ZW5pbmcgZm9yIGNvbm5lY3QgZXZlbnQgKGUuZy4gaXMgZGlzY29ubmVjdGVkIGFuZCBjb25uZWN0cyB0aHJvdWdoIHdhbGxldCBpbnRlcmZhY2UpXG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZW1pdHRlci5saXN0ZW5lckNvdW50KCdjb25uZWN0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0KHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHMubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFpbkNoYW5nZWQoY2hhaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIoY2hhaW4pO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgeyBjaGFpbklkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBvbkNvbm5lY3QoY29ubmVjdEluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKGNvbm5lY3RJbmZvLmNoYWluSWQpO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY29ubmVjdCcsIHsgYWNjb3VudHMsIGNoYWluSWQgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgICAgICAgICBjb25uZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhY2NvdW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50c0NoYW5nZWQgPSB0aGlzLm9uQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoYWluQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHRoaXMub25DaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBJZiBNZXRhTWFzayBlbWl0cyBhIGBjb2RlOiAxMDEzYCBlcnJvciwgd2FpdCBmb3IgcmVjb25uZWN0aW9uIGJlZm9yZSBkaXNjb25uZWN0aW5nXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svcHJvdmlkZXJzL3B1bGwvMTIwXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gMTAxMykge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlciAmJiAhIShhd2FpdCB0aGlzLmdldEFjY291bnRzKCkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICAgICAgLy8gTWFuYWdlIEVJUC0xMTkzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgaWYgKGNoYWluQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdjaGFpbkNoYW5nZWQnLCBjaGFpbkNoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdCA9IHRoaXMub25Db25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Nvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25EaXNwbGF5VXJpKHVyaSkge1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnbWVzc2FnZScsIHsgdHlwZTogJ2Rpc3BsYXlfdXJpJywgZGF0YTogdXJpIH0pO1xuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFNYXNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/metaMask.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/porto.js":
/*!******************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/porto.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   porto: function() { return /* binding */ porto; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var porto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! porto */ \"../node_modules/porto/dist/index.js\");\n/* harmony import */ var porto_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! porto/internal */ \"../node_modules/porto/dist/internal/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\n\n\nfunction porto(parameters = {}) {\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((wagmiConfig) => {\n        const chains = wagmiConfig.chains ?? parameters.chains ?? [];\n        const transports = (() => {\n            if (wagmiConfig.transports)\n                return wagmiConfig.transports;\n            return parameters.transports;\n        })();\n        let porto_promise;\n        let accountsChanged;\n        let chainChanged;\n        let connect;\n        let disconnect;\n        return {\n            async connect({ chainId = chains[0].id, ...rest } = {}) {\n                const isReconnecting = ('isReconnecting' in rest && rest.isReconnecting) || false;\n                const withCapabilities = ('withCapabilities' in rest && rest.withCapabilities) || false;\n                let accounts = [];\n                let currentChainId;\n                if (isReconnecting) {\n                    ;\n                    [accounts, currentChainId] = await Promise.all([\n                        this.getAccounts().catch(() => []),\n                        this.getChainId().catch(() => undefined),\n                    ]);\n                    if (chainId && currentChainId !== chainId) {\n                        const chain = await this.switchChain({ chainId }).catch((error) => {\n                            if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                                throw error;\n                            return { id: currentChainId };\n                        });\n                        currentChainId = chain?.id ?? currentChainId;\n                    }\n                }\n                const provider = (await this.getProvider());\n                try {\n                    if (!accounts?.length && !isReconnecting) {\n                        const res = await provider.request({\n                            method: 'wallet_connect',\n                            params: [\n                                {\n                                    ...('capabilities' in rest\n                                        ? {\n                                            capabilities: porto_internal__WEBPACK_IMPORTED_MODULE_2__.z.encode(porto__WEBPACK_IMPORTED_MODULE_3__.RpcSchema.wallet_connect.Capabilities, rest.capabilities ?? {}),\n                                        }\n                                        : {}),\n                                    chainIds: [\n                                        (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId),\n                                        ...chains\n                                            .filter((x) => x.id !== chainId)\n                                            .map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(x.id)),\n                                    ],\n                                },\n                            ],\n                        });\n                        accounts = res.accounts;\n                        currentChainId = Number(res.chainIds[0]);\n                    }\n                    if (!currentChainId)\n                        throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError();\n                    // Manage EIP-1193 event listeners\n                    // https://eips.ethereum.org/EIPS/eip-1193#events\n                    if (connect) {\n                        provider.removeListener('connect', connect);\n                        connect = undefined;\n                    }\n                    if (!accountsChanged) {\n                        accountsChanged = this.onAccountsChanged.bind(this);\n                        // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,\n                        // while Connector `accountsChanged` is `string[]`\n                        provider.on('accountsChanged', accountsChanged);\n                    }\n                    if (!chainChanged) {\n                        chainChanged = this.onChainChanged.bind(this);\n                        provider.on('chainChanged', chainChanged);\n                    }\n                    if (!disconnect) {\n                        disconnect = this.onDisconnect.bind(this);\n                        provider.on('disconnect', disconnect);\n                    }\n                    return {\n                        accounts: accounts.map((account) => {\n                            if (typeof account === 'object')\n                                return withCapabilities ? account : account.address;\n                            return withCapabilities\n                                ? { address: account, capabilities: {} }\n                                : account;\n                        }),\n                        chainId: currentChainId,\n                    };\n                }\n                catch (err) {\n                    const error = err;\n                    if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code)\n                        throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                    throw error;\n                }\n            },\n            async disconnect() {\n                const provider = await this.getProvider();\n                if (chainChanged) {\n                    provider.removeListener('chainChanged', chainChanged);\n                    chainChanged = undefined;\n                }\n                if (disconnect) {\n                    provider.removeListener('disconnect', disconnect);\n                    disconnect = undefined;\n                }\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n                await provider.request({ method: 'wallet_disconnect' });\n            },\n            async getAccounts() {\n                const provider = await this.getProvider();\n                const accounts = await provider.request({\n                    method: 'eth_accounts',\n                });\n                return accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n            },\n            async getChainId() {\n                const provider = await this.getProvider();\n                const hexChainId = await provider.request({\n                    method: 'eth_chainId',\n                });\n                return Number(hexChainId);\n            },\n            async getPortoInstance() {\n                porto_promise ??= (async () => {\n                    const { Porto } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! porto */ \"../node_modules/porto/dist/index.js\"));\n                    return Porto.create({\n                        ...parameters,\n                        announceProvider: false,\n                        chains: chains,\n                        transports: transports,\n                    });\n                })();\n                return await porto_promise;\n            },\n            async getProvider() {\n                return (await this.getPortoInstance()).provider;\n            },\n            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K',\n            id: 'xyz.ithaca.porto',\n            async isAuthorized() {\n                try {\n                    // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n                    // immediately resolve JSON-RPC requests on page load.\n                    const accounts = await (0,viem__WEBPACK_IMPORTED_MODULE_1__.withRetry)(() => this.getAccounts());\n                    return !!accounts.length;\n                }\n                catch {\n                    return false;\n                }\n            },\n            name: 'Porto',\n            async onAccountsChanged(accounts) {\n                wagmiConfig.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n            },\n            onChainChanged(chain) {\n                const chainId = Number(chain);\n                wagmiConfig.emitter.emit('change', { chainId });\n            },\n            async onConnect(connectInfo) {\n                const accounts = await this.getAccounts();\n                if (accounts.length === 0)\n                    return;\n                const chainId = Number(connectInfo.chainId);\n                wagmiConfig.emitter.emit('connect', { accounts, chainId });\n                // Manage EIP-1193 event listeners\n                const provider = await this.getProvider();\n                if (provider) {\n                    if (connect) {\n                        provider.removeListener('connect', connect);\n                        connect = undefined;\n                    }\n                    if (!accountsChanged) {\n                        accountsChanged = this.onAccountsChanged.bind(this);\n                        // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,\n                        // while Connector `accountsChanged` is `string[]`\n                        provider.on('accountsChanged', accountsChanged);\n                    }\n                    if (!chainChanged) {\n                        chainChanged = this.onChainChanged.bind(this);\n                        provider.on('chainChanged', chainChanged);\n                    }\n                    if (!disconnect) {\n                        disconnect = this.onDisconnect.bind(this);\n                        provider.on('disconnect', disconnect);\n                    }\n                }\n            },\n            async onDisconnect(_error) {\n                const provider = await this.getProvider();\n                wagmiConfig.emitter.emit('disconnect');\n                // Manage EIP-1193 event listeners\n                if (provider) {\n                    if (chainChanged) {\n                        provider.removeListener('chainChanged', chainChanged);\n                        chainChanged = undefined;\n                    }\n                    if (disconnect) {\n                        provider.removeListener('disconnect', disconnect);\n                        disconnect = undefined;\n                    }\n                    if (!connect) {\n                        connect = this.onConnect.bind(this);\n                        provider.on('connect', connect);\n                    }\n                }\n            },\n            async setup() {\n                if (!connect) {\n                    const provider = await this.getProvider();\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n            },\n            async switchChain({ chainId }) {\n                const chain = chains.find((x) => x.id === chainId);\n                if (!chain)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError());\n                const provider = await this.getProvider();\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId) }],\n                });\n                return chain;\n            },\n            type: 'injected',\n        };\n    });\n}\n//# sourceMappingURL=porto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9wb3J0by5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RTtBQUN0QztBQUNDO0FBQ29FO0FBQ2hHLDhCQUE4QjtBQUNyQyxXQUFXLDREQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQyxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RSwrQ0FBK0MsMERBQXdCO0FBQ3ZFO0FBQ0EscUNBQXFDO0FBQ3JDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkNBQUMsUUFBUSw0Q0FBUyxxREFBcUQ7QUFDakk7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSx3Q0FBd0MsaURBQVc7QUFDbkQ7QUFDQTtBQUNBLHdEQUF3RCxpREFBVztBQUNuRTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwREFBd0I7QUFDL0Qsa0NBQWtDLDBEQUF3QjtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkJBQTZCO0FBQ3RFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwyQ0FBMkMsZ0RBQVU7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxRQUFRLHdJQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0NBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0RBQVU7QUFDNUQsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixrREFBZ0IsS0FBSyxnRUFBdUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsaURBQVcsV0FBVztBQUM5RCxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvd2FnbWkvbm9kZV9tb2R1bGVzL0B3YWdtaS9jb25uZWN0b3JzL2Rpc3QvZXNtL3BvcnRvLmpzP2IzNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhaW5Ob3RDb25maWd1cmVkRXJyb3IsIGNyZWF0ZUNvbm5lY3RvciwgfSBmcm9tICdAd2FnbWkvY29yZSc7XG5pbXBvcnQgeyBScGNTY2hlbWEgfSBmcm9tICdwb3J0byc7XG5pbXBvcnQgeyB6IH0gZnJvbSAncG9ydG8vaW50ZXJuYWwnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgbnVtYmVyVG9IZXgsIFN3aXRjaENoYWluRXJyb3IsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgd2l0aFJldHJ5LCB9IGZyb20gJ3ZpZW0nO1xuZXhwb3J0IGZ1bmN0aW9uIHBvcnRvKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3IoKHdhZ21pQ29uZmlnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYWlucyA9IHdhZ21pQ29uZmlnLmNoYWlucyA/PyBwYXJhbWV0ZXJzLmNoYWlucyA/PyBbXTtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0cyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAod2FnbWlDb25maWcudHJhbnNwb3J0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FnbWlDb25maWcudHJhbnNwb3J0cztcbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnRyYW5zcG9ydHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGxldCBwb3J0b19wcm9taXNlO1xuICAgICAgICBsZXQgYWNjb3VudHNDaGFuZ2VkO1xuICAgICAgICBsZXQgY2hhaW5DaGFuZ2VkO1xuICAgICAgICBsZXQgY29ubmVjdDtcbiAgICAgICAgbGV0IGRpc2Nvbm5lY3Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3luYyBjb25uZWN0KHsgY2hhaW5JZCA9IGNoYWluc1swXS5pZCwgLi4ucmVzdCB9ID0ge30pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY29ubmVjdGluZyA9ICgnaXNSZWNvbm5lY3RpbmcnIGluIHJlc3QgJiYgcmVzdC5pc1JlY29ubmVjdGluZykgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aENhcGFiaWxpdGllcyA9ICgnd2l0aENhcGFiaWxpdGllcycgaW4gcmVzdCAmJiByZXN0LndpdGhDYXBhYmlsaXRpZXMpIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbYWNjb3VudHMsIGN1cnJlbnRDaGFpbklkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWNjb3VudHMoKS5jYXRjaCgoKSA9PiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENoYWluSWQoKS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgJiYgY3VycmVudENoYWluSWQgIT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluID0gYXdhaXQgdGhpcy5zd2l0Y2hDaGFpbih7IGNoYWluSWQgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZDogY3VycmVudENoYWluSWQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluSWQgPSBjaGFpbj8uaWQgPz8gY3VycmVudENoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSAoYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRzPy5sZW5ndGggJiYgIWlzUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLignY2FwYWJpbGl0aWVzJyBpbiByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllczogei5lbmNvZGUoUnBjU2NoZW1hLndhbGxldF9jb25uZWN0LkNhcGFiaWxpdGllcywgcmVzdC5jYXBhYmlsaXRpZXMgPz8ge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyVG9IZXgoY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hhaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+IHguaWQgIT09IGNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHgpID0+IG51bWJlclRvSGV4KHguaWQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMgPSByZXMuYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW5JZCA9IE51bWJlcihyZXMuY2hhaW5JZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hhaW5Ob3RDb25maWd1cmVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFuYWdlIEVJUC0xMTkzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMjZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNDaGFuZ2VkID0gdGhpcy5vbkFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9ydG8gUHJvdmlkZXIgdXNlcyBPeCwgd2hpY2ggdXNlcyBgcmVhZG9ubHkgQWRkcmVzcy5BZGRyZXNzW11gIGZvciBgYWNjb3VudHNDaGFuZ2VkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIENvbm5lY3RvciBgYWNjb3VudHNDaGFuZ2VkYCBpcyBgc3RyaW5nW11gXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoYWluQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKGFjY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjY291bnQgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2l0aENhcGFiaWxpdGllcyA/IGFjY291bnQgOiBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhDYXBhYmlsaXRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGFkZHJlc3M6IGFjY291bnQsIGNhcGFiaWxpdGllczoge30gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFjY291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHRoaXMub25Db25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6ICd3YWxsZXRfZGlzY29ubmVjdCcgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleENoYWluSWQgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoaGV4Q2hhaW5JZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgZ2V0UG9ydG9JbnN0YW5jZSgpIHtcbiAgICAgICAgICAgICAgICBwb3J0b19wcm9taXNlID8/PSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IFBvcnRvIH0gPSBhd2FpdCBpbXBvcnQoJ3BvcnRvJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQb3J0by5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm91bmNlUHJvdmlkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5zOiBjaGFpbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRzOiB0cmFuc3BvcnRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwb3J0b19wcm9taXNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIGdldFByb3ZpZGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRQb3J0b0luc3RhbmNlKCkpLnByb3ZpZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGljb246ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOREl5SWlCb1pXbG5hSFE5SWpReU1pSWdkbWxsZDBKdmVEMGlNQ0F3SURReU1pQTBNaklpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK0NqeHlaV04wSUhkcFpIUm9QU0kwTWpJaUlHaGxhV2RvZEQwaU5ESXlJaUJtYVd4c1BTSmliR0ZqYXlJdlBnbzhaeUJqYkdsd0xYQmhkR2c5SW5WeWJDZ2pZMnhwY0RCZk1WOHhOU2tpUGdvOGNHRjBhQ0JrUFNKTk9ERWdNamcyTGpNMk5rTTRNU0F5T0RBdU9Ea3pJRGcxTGpRMU1EVWdNamMyTGpRMU5TQTVNQzQ1TkRBMElESTNOaTQwTlRWSU16STVMalV4TVVNek16VXVNREF4SURJM05pNDBOVFVnTXpNNUxqUTFNaUF5T0RBdU9Ea3pJRE16T1M0ME5USWdNamcyTGpNMk5sWXpNRFl1TVRnNFF6TXpPUzQwTlRJZ016RXhMalkyTWlBek16VXVNREF4SURNeE5pNHdPVGtnTXpJNUxqVXhNU0F6TVRZdU1EazVTRGt3TGprME1EUkRPRFV1TkRVd05TQXpNVFl1TURrNUlEZ3hJRE14TVM0Mk5qSWdPREVnTXpBMkxqRTRPRll5T0RZdU16WTJXaUlnWm1sc2JEMGlkMmhwZEdVaUlHWnBiR3d0YjNCaFkybDBlVDBpTUM0MUlpOCtDanh3WVhSb0lHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk9UQXVPVFF3TkNBeU16UXVPREk0UXpnMUxqUTFNRFVnTWpNMExqZ3lPQ0E0TVNBeU16a3VNalkySURneElESTBOQzQzTXpsV01qY3hMalV6TVVNNE15NDRORE15SURJMk9TNDJNek1nT0RjdU1qWXlNaUF5TmpndU5USTJJRGt3TGprME1EUWdNalk0TGpVeU5rZ3pNamt1TlRFeFF6TXpNeTR4T0RnZ01qWTRMalV5TmlBek16WXVOakE0SURJMk9TNDJNek1nTXpNNUxqUTFNaUF5TnpFdU5UTXhWakkwTkM0M016bERNek01TGpRMU1pQXlNemt1TWpZMklETXpOUzR3TURFZ01qTTBMamd5T0NBek1qa3VOVEV4SURJek5DNDRNamhJT1RBdU9UUXdORnBOTXpNNUxqUTFNaUF5T0RZdU16WTJRek16T1M0ME5USWdNamd3TGpnNU15QXpNelV1TURBeElESTNOaTQwTlRVZ016STVMalV4TVNBeU56WXVORFUxU0Rrd0xqazBNRFJET0RVdU5EVXdOU0F5TnpZdU5EVTFJRGd4SURJNE1DNDRPVE1nT0RFZ01qZzJMak0yTmxZek1EWXVNVGxET0RFZ016RXhMalkyTkNBNE5TNDBOVEExSURNeE5pNHhNREVnT1RBdU9UUXdOQ0F6TVRZdU1UQXhTRE15T1M0MU1URkRNek0xTGpBd01TQXpNVFl1TVRBeElETXpPUzQwTlRJZ016RXhMalkyTkNBek16a3VORFV5SURNd05pNHhPVll5T0RZdU16WTJXaUlnWm1sc2JEMGlkMmhwZEdVaUlHWnBiR3d0YjNCaFkybDBlVDBpTUM0MUlpOCtDanh3WVhSb0lHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk9UQXVPVFF3TkNBeE9UTXVNakF4UXpnMUxqUTFNRFVnTVRrekxqSXdNU0E0TVNBeE9UY3VOak00SURneElESXdNeTR4TVRKV01qSTVMamt3TTBNNE15NDRORE15SURJeU9DNHdNRFlnT0RjdU1qWXlNaUF5TWpZdU9EazVJRGt3TGprME1EUWdNakkyTGpnNU9VZ3pNamt1TlRFeFF6TXpNeTR4T0RnZ01qSTJMamc1T1NBek16WXVOakE0SURJeU9DNHdNRFlnTXpNNUxqUTFNaUF5TWprdU9UQXpWakl3TXk0eE1USkRNek01TGpRMU1pQXhPVGN1TmpNNElETXpOUzR3TURFZ01Ua3pMakl3TVNBek1qa3VOVEV4SURFNU15NHlNREZJT1RBdU9UUXdORnBOTXpNNUxqUTFNaUF5TkRRdU56TTVRek16T1M0ME5USWdNak01TGpJMk5TQXpNelV1TURBeElESXpOQzQ0TWpnZ016STVMalV4TVNBeU16UXVPREk0U0Rrd0xqazBNRFJET0RVdU5EVXdOU0F5TXpRdU9ESTRJRGd4SURJek9TNHlOalVnT0RFZ01qUTBMamN6T1ZZeU56RXVOVE5ET0RFdU1qRTNOU0F5TnpFdU16ZzFJRGd4TGpRek9ETWdNamN4TGpJME5TQTRNUzQyTmpJMElESTNNUzR4TURsRE9ETXVPRE15TlNBeU5qa3VOemswSURnMkxqTXdOVFFnTWpZNExqa3lOeUE0T0M0NU5USXpJREkyT0M0Mk16VkRPRGt1TmpBMU1TQXlOamd1TlRZeklEa3dMakkyT0RRZ01qWTRMalV5TmlBNU1DNDVOREEwSURJMk9DNDFNalpJTXpJNUxqVXhNVU16TXpBdU1UZ3pJREkyT0M0MU1qWWdNek13TGpnME5pQXlOamd1TlRZeklETXpNUzQwT1RnZ01qWTRMall6TlVNek16UXVOREU1SURJMk9DNDVOVGNnTXpNM0xqRXlPQ0F5TmprdU9UZ2dNek01TGpRMU1pQXlOekV1TlROV01qUTBMamN6T1ZwTk16TTVMalExTWlBeU9EWXVNelkyUXpNek9TNDBOVElnTWpneExqQXlNU0F6TXpVdU1qQTJJREkzTmk0Mk5qTWdNekk1TGpnNU15QXlOell1TkRZeVF6TXlPUzQzTmpjZ01qYzJMalExTnlBek1qa3VOalFnTWpjMkxqUTFOU0F6TWprdU5URXhJREkzTmk0ME5UVklPVEF1T1RRd05FTTROUzQwTlRBMUlESTNOaTQwTlRVZ09ERWdNamd3TGpnNU15QTRNU0F5T0RZdU16WTJWak13Tmk0eE9EaERPREVnTXpFeExqWTJNaUE0TlM0ME5UQTFJRE14Tmk0eE1ERWdPVEF1T1RRd05DQXpNVFl1TVRBeFNETXlPUzQxTVRGRE16TTFMakF3TVNBek1UWXVNVEF4SURNek9TNDBOVElnTXpFeExqWTJNaUF6TXprdU5EVXlJRE13Tmk0eE9EaFdNamcyTGpNMk5sb2lJR1pwYkd3OUluZG9hWFJsSWlCbWFXeHNMVzl3WVdOcGRIazlJakF1TlNJdlBnbzhjR0YwYUNCdmNHRmphWFI1UFNJd0xqTWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5PVGd1TURFME5pQXhNRFJET0RndU5qRTNOeUF4TURRZ09ERWdNVEV4TGpVNU5TQTRNU0F4TWpBdU9UWTFWakU0T0M0eU56WkRPRE11T0RRek1pQXhPRFl1TXpjNUlEZzNMakkyTWpJZ01UZzFMakkzTWlBNU1DNDVOREEwSURFNE5TNHlOekpJTXpJNUxqVXhNVU16TXpNdU1UZzRJREU0TlM0eU56SWdNek0yTGpZd09DQXhPRFl1TXpjNUlETXpPUzQwTlRJZ01UZzRMakkzTmxZeE1qQXVPVFkxUXpNek9TNDBOVElnTVRFeExqVTVOU0F6TXpFdU9ETXpJREV3TkNBek1qSXVORE0zSURFd05FZzVPQzR3TVRRMldrMHpNemt1TkRVeUlESXdNeTR4TVRKRE16TTVMalExTWlBeE9UY3VOak00SURNek5TNHdNREVnTVRrekxqSXdNU0F6TWprdU5URXhJREU1TXk0eU1ERklPVEF1T1RRd05FTTROUzQwTlRBMUlERTVNeTR5TURFZ09ERWdNVGszTGpZek9DQTRNU0F5TURNdU1URXlWakl5T1M0NU1ETkRPREV1TWpFM05TQXlNamt1TnpVNElEZ3hMalF6T0RNZ01qSTVMall4T0NBNE1TNDJOakkwSURJeU9TNDBPREpET0RNdU9ETXlOU0F5TWpndU1UWTNJRGcyTGpNd05UUWdNakkzTGpNZ09EZ3VPVFV5TXlBeU1qY3VNREE0UXpnNUxqWXdOVEVnTWpJMkxqa3pOaUE1TUM0eU5qZzBJREl5Tmk0NE9Ua2dPVEF1T1RRd05DQXlNall1T0RrNVNETXlPUzQxTVRGRE16TXdMakU0TXlBeU1qWXVPRGs1SURNek1DNDRORFlnTWpJMkxqa3pOaUF6TXpFdU5EazRJREl5Tnk0d01EaERNek0wTGpReE9TQXlNamN1TXpNZ016TTNMakV5T0NBeU1qZ3VNelV5SURNek9TNDBOVElnTWpJNUxqa3dNMVl5TURNdU1URXlXazB6TXprdU5EVXlJREkwTkM0M016bERNek01TGpRMU1pQXlNemt1TXpreklETXpOUzR5TURZZ01qTTFMakF6TmlBek1qa3VPRGt6SURJek5DNDRNelZETXpJNUxqYzJOeUF5TXpRdU9ETWdNekk1TGpZMElESXpOQzQ0TWpnZ016STVMalV4TVNBeU16UXVPREk0U0Rrd0xqazBNRFJET0RVdU5EVXdOU0F5TXpRdU9ESTRJRGd4SURJek9TNHlOalVnT0RFZ01qUTBMamN6T1ZZeU56RXVOVE5NT0RFdU1EY3dOeUF5TnpFdU5EZ3pRemd4TGpJMk5UTWdNamN4TGpNMU5TQTRNUzQwTmpJMUlESTNNUzR5TXlBNE1TNDJOakkwSURJM01TNHhNRGxET0RFdU9UQTRNeUF5TnpBdU9UWWdPREl1TVRVNE1TQXlOekF1T0RFM0lEZ3lMalF4TVRjZ01qY3dMalkzT1VNNE5DNHpPVFV6SURJMk9TNDJNRFVnT0RZdU5qQTFOQ0F5TmpndU9EazBJRGc0TGprMU1qTWdNalk0TGpZek5VTTRPUzR3TURVeUlESTJPQzQyTWprZ09Ea3VNRFU0SURJMk9DNDJNalFnT0RrdU1URXhJREkyT0M0Mk1UaERPRGt1TnpFeU5TQXlOamd1TlRVM0lEa3dMak15TWpnZ01qWTRMalV5TmlBNU1DNDVOREEwSURJMk9DNDFNalpJTXpJNUxqVXhNVU16TWprdU56TTRJREkyT0M0MU1qWWdNekk1TGprMk5TQXlOamd1TlRNZ016TXdMakU1TWlBeU5qZ3VOVE01UXpNek1DNDJNekVnTWpZNExqVTFOU0F6TXpFdU1EWTNJREkyT0M0MU9EY2dNek14TGpRNU9DQXlOamd1TmpNMVF6TXpOQzQwTVRrZ01qWTRMamsxTnlBek16Y3VNVEk0SURJMk9TNDVPQ0F6TXprdU5EVXlJREkzTVM0MU0xWXlORFF1TnpNNVdrMHpNemt1TkRVeUlESTROaTR6TmpaRE16TTVMalExTWlBeU9ERXVNREl4SURNek5TNHlNRFlnTWpjMkxqWTJNeUF6TWprdU9Ea3pJREkzTmk0ME5qSk1Nekk1TGpnMk5TQXlOell1TkRZeFF6TXlPUzQzTkRnZ01qYzJMalExTnlBek1qa3VOakk1SURJM05pNDBOVFVnTXpJNUxqVXhNU0F5TnpZdU5EVTFTRGt3TGprME1EUkRPRFV1TkRVd05TQXlOell1TkRVMUlEZ3hJREk0TUM0NE9UTWdPREVnTWpnMkxqTTJObFl6TURZdU1UZzRRemd4SURNeE1TNDJOaklnT0RVdU5EVXdOU0F6TVRZdU1UQXhJRGt3TGprME1EUWdNekUyTGpFd01VZ3pNamt1TlRFeFF6TXpOUzR3TURFZ016RTJMakV3TVNBek16a3VORFV5SURNeE1TNDJOaklnTXpNNUxqUTFNaUF6TURZdU1UZzRWakk0Tmk0ek5qWmFJaUJtYVd4c1BTSjNhR2wwWlNJdlBnbzhjR0YwYUNCa1BTSk5Nalk1TGpnMk9DQXhNekV1TnpVeVF6STJPUzQ0TmpnZ01USTJMakkzT0NBeU56UXVNekU0SURFeU1TNDROQ0F5TnprdU9EQTRJREV5TVM0NE5FZ3pNVEV1TmpFNFF6TXhOeTR4TURnZ01USXhMamcwSURNeU1TNDFOVGdnTVRJMkxqSTNPQ0F6TWpFdU5UVTRJREV6TVM0M05USldNVFl4TGpRNE5VTXpNakV1TlRVNElERTJOaTQ1TlRrZ016RTNMakV3T0NBeE56RXVNemsySURNeE1TNDJNVGdnTVRjeExqTTVOa2d5TnprdU9EQTRRekkzTkM0ek1UZ2dNVGN4TGpNNU5pQXlOamt1T0RZNElERTJOaTQ1TlRrZ01qWTVMamcyT0NBeE5qRXVORGcxVmpFek1TNDNOVEphSWlCbWFXeHNQU0ozYUdsMFpTSXZQZ284TDJjK0NqeGtaV1p6UGdvOFkyeHBjRkJoZEdnZ2FXUTlJbU5zYVhBd1h6RmZNVFVpUGdvOGNtVmpkQ0IzYVdSMGFEMGlNalU1SWlCb1pXbG5hSFE5SWpJeE15SWdabWxzYkQwaWQyaHBkR1VpSUhSeVlXNXpabTl5YlQwaWRISmhibk5zWVhSbEtEZ3hJREV3TkNraUx6NEtQQzlqYkdsd1VHRjBhRDRLUEM5a1pXWnpQZ284TDNOMlp6NEsnLFxuICAgICAgICAgICAgaWQ6ICd4eXouaXRoYWNhLnBvcnRvJyxcbiAgICAgICAgICAgIGFzeW5jIGlzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcmV0cnkgc3RyYXRlZ3kgYXMgc29tZSBpbmplY3RlZCB3YWxsZXRzIChlLmcuIE1ldGFNYXNrKSBmYWlsIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmUgSlNPTi1SUEMgcmVxdWVzdHMgb24gcGFnZSBsb2FkLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHdpdGhSZXRyeSgoKSA9PiB0aGlzLmdldEFjY291bnRzKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFhY2NvdW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiAnUG9ydG8nLFxuICAgICAgICAgICAgYXN5bmMgb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgICAgICAgICB3YWdtaUNvbmZpZy5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRzLm1hcCgoeCkgPT4gZ2V0QWRkcmVzcyh4KSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DaGFpbkNoYW5nZWQoY2hhaW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKGNoYWluKTtcbiAgICAgICAgICAgICAgICB3YWdtaUNvbmZpZy5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBvbkNvbm5lY3QoY29ubmVjdEluZm8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihjb25uZWN0SW5mby5jaGFpbklkKTtcbiAgICAgICAgICAgICAgICB3YWdtaUNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Nvbm5lY3QnLCB7IGFjY291bnRzLCBjaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50c0NoYW5nZWQgPSB0aGlzLm9uQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3J0byBQcm92aWRlciB1c2VzIE94LCB3aGljaCB1c2VzIGByZWFkb25seSBBZGRyZXNzLkFkZHJlc3NbXWAgZm9yIGBhY2NvdW50c0NoYW5nZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpbGUgQ29ubmVjdG9yIGBhY2NvdW50c0NoYW5nZWRgIGlzIGBzdHJpbmdbXWBcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB0aGlzLm9uQ2hhaW5DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBvbkRpc2Nvbm5lY3QoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgd2FnbWlDb25maWcuZW1pdHRlci5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgLy8gTWFuYWdlIEVJUC0xMTkzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgc2V0dXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Nvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgc3dpdGNoQ2hhaW4oeyBjaGFpbklkIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNoYWlucy5maW5kKCh4KSA9PiB4LmlkID09PSBjaGFpbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3dpdGNoQ2hhaW5FcnJvcihuZXcgQ2hhaW5Ob3RDb25maWd1cmVkRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbklkKSB9XSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ2luamVjdGVkJyxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcnRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/porto.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/safe.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/safe.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   safe: function() { return /* binding */ safe; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\nsafe.type = 'safe';\nfunction safe(parameters = {}) {\n    const { shimDisconnect = false } = parameters;\n    let provider_;\n    let disconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((config) => ({\n        id: 'safe',\n        name: 'Safe',\n        type: safe.type,\n        async connect({ withCapabilities } = {}) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n            const accounts = await this.getAccounts();\n            const chainId = await this.getChainId();\n            if (!disconnect) {\n                disconnect = this.onDisconnect.bind(this);\n                provider.on('disconnect', disconnect);\n            }\n            // Remove disconnected shim if it exists\n            if (shimDisconnect)\n                await config.storage?.removeItem('safe.disconnected');\n            return {\n                // TODO(v3): Make `withCapabilities: true` default behavior\n                accounts: (withCapabilities\n                    ? accounts.map((address) => ({ address, capabilities: {} }))\n                    : accounts),\n                chainId,\n            };\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            // Add shim signalling connector is disconnected\n            if (shimDisconnect)\n                await config.storage?.setItem('safe.disconnected', true);\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n            return (await provider.request({ method: 'eth_accounts' })).map(viem__WEBPACK_IMPORTED_MODULE_1__.getAddress);\n        },\n        async getProvider() {\n            // Only allowed in iframe context\n            const isIframe = typeof window !== 'undefined' && window?.parent !== window;\n            if (!isIframe)\n                return;\n            if (!provider_) {\n                const { default: SDK } = await __webpack_require__.e(/*! import() */ \"node_modules_safe-global_safe-apps-sdk_dist_esm_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @safe-global/safe-apps-sdk */ \"../node_modules/@safe-global/safe-apps-sdk/dist/esm/index.js\"));\n                const sdk = new SDK(parameters);\n                // `getInfo` hangs when not used in Safe App iFrame\n                // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n                const safe = await (0,viem__WEBPACK_IMPORTED_MODULE_1__.withTimeout)(() => sdk.safe.getInfo(), {\n                    timeout: parameters.unstable_getInfoTimeout ?? 10,\n                });\n                if (!safe)\n                    throw new Error('Could not load Safe information');\n                // Unwrapping import for Vite compatibility.\n                // See: https://github.com/vitejs/vite/issues/9703\n                const SafeAppProvider = await (async () => {\n                    const Provider = await __webpack_require__.e(/*! import() */ \"node_modules_safe-global_safe-apps-provider_dist_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! @safe-global/safe-apps-provider */ \"../node_modules/@safe-global/safe-apps-provider/dist/index.js\", 19));\n                    if (typeof Provider.SafeAppProvider !== 'function' &&\n                        typeof Provider.default.SafeAppProvider === 'function')\n                        return Provider.default.SafeAppProvider;\n                    return Provider.SafeAppProvider;\n                })();\n                provider_ = new SafeAppProvider(safe, sdk);\n            }\n            return provider_;\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n            return Number(provider.chainId);\n        },\n        async isAuthorized() {\n            try {\n                const isDisconnected = shimDisconnect &&\n                    // If shim exists in storage, connector is disconnected\n                    (await config.storage?.getItem('safe.disconnected'));\n                if (isDisconnected)\n                    return false;\n                const accounts = await this.getAccounts();\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        onAccountsChanged() {\n            // Not relevant for Safe because changing account requires app reload.\n        },\n        onChainChanged() {\n            // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n        },\n        onDisconnect() {\n            config.emitter.emit('disconnect');\n        },\n    }));\n}\n//# sourceMappingURL=safe.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS9zYWZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzRTtBQUN2QjtBQUMvQztBQUNPLDZCQUE2QjtBQUNwQyxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLElBQUk7QUFDL0M7QUFDQTtBQUNBLDBCQUEwQiw4REFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQXFCO0FBQy9DLDZDQUE2Qyx3QkFBd0IsT0FBTyw0Q0FBVTtBQUN0RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWUsUUFBUSx1UEFBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlEQUFXO0FBQzlDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb1FBQXlDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQXFCO0FBQy9DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvd2FnbWkvbm9kZV9tb2R1bGVzL0B3YWdtaS9jb25uZWN0b3JzL2Rpc3QvZXNtL3NhZmUuanM/OTVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb25uZWN0b3IsIFByb3ZpZGVyTm90Rm91bmRFcnJvciwgfSBmcm9tICdAd2FnbWkvY29yZSc7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCB3aXRoVGltZW91dCB9IGZyb20gJ3ZpZW0nO1xuc2FmZS50eXBlID0gJ3NhZmUnO1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmUocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaGltRGlzY29ubmVjdCA9IGZhbHNlIH0gPSBwYXJhbWV0ZXJzO1xuICAgIGxldCBwcm92aWRlcl87XG4gICAgbGV0IGRpc2Nvbm5lY3Q7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbm5lY3RvcigoY29uZmlnKSA9PiAoe1xuICAgICAgICBpZDogJ3NhZmUnLFxuICAgICAgICBuYW1lOiAnU2FmZScsXG4gICAgICAgIHR5cGU6IHNhZmUudHlwZSxcbiAgICAgICAgYXN5bmMgY29ubmVjdCh7IHdpdGhDYXBhYmlsaXRpZXMgfSA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICBpZiAoIWRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGRpc2Nvbm5lY3RlZCBzaGltIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgaWYgKHNoaW1EaXNjb25uZWN0KVxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbmZpZy5zdG9yYWdlPy5yZW1vdmVJdGVtKCdzYWZlLmRpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHYzKTogTWFrZSBgd2l0aENhcGFiaWxpdGllczogdHJ1ZWAgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGFjY291bnRzOiAod2l0aENhcGFiaWxpdGllc1xuICAgICAgICAgICAgICAgICAgICA/IGFjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gKHsgYWRkcmVzcywgY2FwYWJpbGl0aWVzOiB7fSB9KSlcbiAgICAgICAgICAgICAgICAgICAgOiBhY2NvdW50cyksXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgc2hpbSBzaWduYWxsaW5nIGNvbm5lY3RvciBpcyBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgIGlmIChzaGltRGlzY29ubmVjdClcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25maWcuc3RvcmFnZT8uc2V0SXRlbSgnc2FmZS5kaXNjb25uZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2FjY291bnRzJyB9KSkubWFwKGdldEFkZHJlc3MpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRQcm92aWRlcigpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWxsb3dlZCBpbiBpZnJhbWUgY29udGV4dFxuICAgICAgICAgICAgY29uc3QgaXNJZnJhbWUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c/LnBhcmVudCAhPT0gd2luZG93O1xuICAgICAgICAgICAgaWYgKCFpc0lmcmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyXykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogU0RLIH0gPSBhd2FpdCBpbXBvcnQoJ0BzYWZlLWdsb2JhbC9zYWZlLWFwcHMtc2RrJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2RrID0gbmV3IFNESyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICAvLyBgZ2V0SW5mb2AgaGFuZ3Mgd2hlbiBub3QgdXNlZCBpbiBTYWZlIEFwcCBpRnJhbWVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2FmZS1nbG9iYWwvc2FmZS1hcHBzLXNkay9pc3N1ZXMvMjYzI2lzc3VlY29tbWVudC0xMDI5ODM1ODQwXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FmZSA9IGF3YWl0IHdpdGhUaW1lb3V0KCgpID0+IHNkay5zYWZlLmdldEluZm8oKSwge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiBwYXJhbWV0ZXJzLnVuc3RhYmxlX2dldEluZm9UaW1lb3V0ID8/IDEwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghc2FmZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCBTYWZlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgLy8gVW53cmFwcGluZyBpbXBvcnQgZm9yIFZpdGUgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvOTcwM1xuICAgICAgICAgICAgICAgIGNvbnN0IFNhZmVBcHBQcm92aWRlciA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFByb3ZpZGVyID0gYXdhaXQgaW1wb3J0KCdAc2FmZS1nbG9iYWwvc2FmZS1hcHBzLXByb3ZpZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvdmlkZXIuU2FmZUFwcFByb3ZpZGVyICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgUHJvdmlkZXIuZGVmYXVsdC5TYWZlQXBwUHJvdmlkZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvdmlkZXIuZGVmYXVsdC5TYWZlQXBwUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm92aWRlci5TYWZlQXBwUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl8gPSBuZXcgU2FmZUFwcFByb3ZpZGVyKHNhZmUsIHNkayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJfO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIocHJvdmlkZXIuY2hhaW5JZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGlzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEaXNjb25uZWN0ZWQgPSBzaGltRGlzY29ubmVjdCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzaGltIGV4aXN0cyBpbiBzdG9yYWdlLCBjb25uZWN0b3IgaXMgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIChhd2FpdCBjb25maWcuc3RvcmFnZT8uZ2V0SXRlbSgnc2FmZS5kaXNjb25uZWN0ZWQnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlzY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhYWNjb3VudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25BY2NvdW50c0NoYW5nZWQoKSB7XG4gICAgICAgICAgICAvLyBOb3QgcmVsZXZhbnQgZm9yIFNhZmUgYmVjYXVzZSBjaGFuZ2luZyBhY2NvdW50IHJlcXVpcmVzIGFwcCByZWxvYWQuXG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhaW5DaGFuZ2VkKCkge1xuICAgICAgICAgICAgLy8gTm90IHJlbGV2YW50IGZvciBTYWZlIGJlY2F1c2UgU2FmZSBzbWFydCBjb250cmFjdCB3YWxsZXRzIG9ubHkgZXhpc3Qgb24gc2luZ2xlIGNoYWluLlxuICAgICAgICB9LFxuICAgICAgICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/safe.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/version.js":
/*!********************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/version.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\nconst version = '6.1.3';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvd2FnbWkvbm9kZV9tb2R1bGVzL0B3YWdtaS9jb25uZWN0b3JzL2Rpc3QvZXNtL3ZlcnNpb24uanM/MDgyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICc2LjEuMyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/version.js\n"));

/***/ }),

/***/ "../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/walletConnect.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/walletConnect.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   walletConnect: function() { return /* binding */ walletConnect; }\n/* harmony export */ });\n/* harmony import */ var _wagmi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wagmi/core */ \"../node_modules/@wagmi/core/dist/esm/exports/index.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"../node_modules/viem/_esm/index.js\");\n\n\nwalletConnect.type = 'walletConnect';\n/**\n * @deprecated **NOTE: This connector uses a vulnerable dependency downstream** (`@walletconnect/ethereum-provider@2.21.1` > `@reown/appkit@1.8.9` > `@reown/appkit-utils@1.8.9` > `@walletconnect/logger@2.1.2` > `pino@7.11.0`). You should override `pino` to a secure version via your package manager:\n *\n * ### npm\n * ```json\n * {\n *   \"overrides\": {\n *     \"@walletconnect/logger\": {\n *       \"pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * ### pnpm\n * ```json\n * {\n *   \"pnpm\": {\n *     \"overrides\": {\n *       \"@walletconnect/logger>pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * ### yarn\n * ```json\n * {\n *   \"resolutions\": {\n *     \"@walletconnect/logger/pino\": \"10.0.0\"\n *   }\n * }\n * ```\n *\n * ### bun\n * ```json\n * {\n *   \"overrides\": {\n *     \"@walletconnect/logger\": {\n *       \"pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * Normally the Wagmi team would upgrade `@walletconnect/ethereum-provider` to a fixed version for you, but `@walletconnect/ethereum-provider` was relicensed recently from Apache to a [non-permissive license](https://github.com/reown-com/appkit/blob/main/LICENSE.md). We are trying to get the WalletConnect team to release a version that closes the vulnerability under the old Apache license.\n */\nfunction walletConnect(parameters) {\n    const isNewChainsStale = parameters.isNewChainsStale ?? true;\n    let provider_;\n    let providerPromise;\n    const NAMESPACE = 'eip155';\n    let accountsChanged;\n    let chainChanged;\n    let connect;\n    let displayUri;\n    let sessionDelete;\n    let disconnect;\n    return (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.createConnector)((config) => ({\n        id: 'walletConnect',\n        name: 'WalletConnect',\n        type: walletConnect.type,\n        async setup() {\n            const provider = await this.getProvider().catch(() => null);\n            if (!provider)\n                return;\n            if (!connect) {\n                connect = this.onConnect.bind(this);\n                provider.on('connect', connect);\n            }\n            if (!sessionDelete) {\n                sessionDelete = this.onSessionDelete.bind(this);\n                provider.on('session_delete', sessionDelete);\n            }\n        },\n        async connect({ chainId, withCapabilities, ...rest } = {}) {\n            try {\n                const provider = await this.getProvider();\n                if (!provider)\n                    throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n                if (!displayUri) {\n                    displayUri = this.onDisplayUri;\n                    provider.on('display_uri', displayUri);\n                }\n                let targetChainId = chainId;\n                if (!targetChainId) {\n                    const state = (await config.storage?.getItem('state')) ?? {};\n                    const isChainSupported = config.chains.some((x) => x.id === state.chainId);\n                    if (isChainSupported)\n                        targetChainId = state.chainId;\n                    else\n                        targetChainId = config.chains[0]?.id;\n                }\n                if (!targetChainId)\n                    throw new Error('No chains found on connector.');\n                const isChainsStale = await this.isChainsStale();\n                // If there is an active session with stale chains, disconnect current session.\n                if (provider.session && isChainsStale)\n                    await provider.disconnect();\n                // If there isn't an active session or chains are stale, connect.\n                if (!provider.session || isChainsStale) {\n                    const optionalChains = config.chains\n                        .filter((chain) => chain.id !== targetChainId)\n                        .map((optionalChain) => optionalChain.id);\n                    await provider.connect({\n                        optionalChains: [targetChainId, ...optionalChains],\n                        ...('pairingTopic' in rest\n                            ? { pairingTopic: rest.pairingTopic }\n                            : {}),\n                    });\n                    this.setRequestedChainsIds(config.chains.map((x) => x.id));\n                }\n                // If session exists and chains are authorized, enable provider for required chain\n                const accounts = (await provider.enable()).map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError.code &&\n                            error.cause?.message !==\n                                'Missing or invalid. request() method: wallet_addEthereumChain')\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                if (displayUri) {\n                    provider.removeListener('display_uri', displayUri);\n                    displayUri = undefined;\n                }\n                if (connect) {\n                    provider.removeListener('connect', connect);\n                    connect = undefined;\n                }\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                if (!sessionDelete) {\n                    sessionDelete = this.onSessionDelete.bind(this);\n                    provider.on('session_delete', sessionDelete);\n                }\n                return {\n                    accounts: (withCapabilities\n                        ? accounts.map((address) => ({ address, capabilities: {} }))\n                        : accounts),\n                    chainId: currentChainId,\n                };\n            }\n            catch (error) {\n                if (/(user rejected|connection request reset)/i.test(error?.message)) {\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                }\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            try {\n                await provider?.disconnect();\n            }\n            catch (error) {\n                if (!/No matching key/i.test(error.message))\n                    throw error;\n            }\n            finally {\n                if (chainChanged) {\n                    provider?.removeListener('chainChanged', chainChanged);\n                    chainChanged = undefined;\n                }\n                if (disconnect) {\n                    provider?.removeListener('disconnect', disconnect);\n                    disconnect = undefined;\n                }\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider?.on('connect', connect);\n                }\n                if (accountsChanged) {\n                    provider?.removeListener('accountsChanged', accountsChanged);\n                    accountsChanged = undefined;\n                }\n                if (sessionDelete) {\n                    provider?.removeListener('session_delete', sessionDelete);\n                    sessionDelete = undefined;\n                }\n                this.setRequestedChainsIds([]);\n            }\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            return provider.accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getProvider({ chainId } = {}) {\n            async function initProvider() {\n                const optionalChains = config.chains.map((x) => x.id);\n                if (!optionalChains.length)\n                    return;\n                const { EthereumProvider } = await __webpack_require__.e(/*! import() */ \"node_modules_walletconnect_ethereum-provider_dist_index_es_js\").then(__webpack_require__.bind(__webpack_require__, /*! @walletconnect/ethereum-provider */ \"../node_modules/@walletconnect/ethereum-provider/dist/index.es.js\"));\n                return await EthereumProvider.init({\n                    ...parameters,\n                    disableProviderPing: true,\n                    optionalChains,\n                    projectId: parameters.projectId,\n                    rpcMap: Object.fromEntries(config.chains.map((chain) => {\n                        const [url] = (0,_wagmi_core__WEBPACK_IMPORTED_MODULE_0__.extractRpcUrls)({\n                            chain,\n                            transports: config.transports,\n                        });\n                        return [chain.id, url];\n                    })),\n                    showQrModal: parameters.showQrModal ?? true,\n                });\n            }\n            if (!provider_) {\n                if (!providerPromise)\n                    providerPromise = initProvider();\n                provider_ = await providerPromise;\n                provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);\n            }\n            if (chainId)\n                await this.switchChain?.({ chainId });\n            return provider_;\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            return provider.chainId;\n        },\n        async isAuthorized() {\n            try {\n                const [accounts, provider] = await Promise.all([\n                    this.getAccounts(),\n                    this.getProvider(),\n                ]);\n                // If an account does not exist on the session, then the connector is unauthorized.\n                if (!accounts.length)\n                    return false;\n                // If the chains are stale on the session, then the connector is unauthorized.\n                const isChainsStale = await this.isChainsStale();\n                if (isChainsStale && provider.session) {\n                    await provider.disconnect().catch(() => { });\n                    return false;\n                }\n                return true;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ProviderNotFoundError();\n            const chain = config.chains.find((x) => x.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_1__.SwitchChainError(new _wagmi_core__WEBPACK_IMPORTED_MODULE_0__.ChainNotConfiguredError());\n            try {\n                await Promise.all([\n                    new Promise((resolve) => {\n                        const listener = ({ chainId: currentChainId, }) => {\n                            if (currentChainId === chainId) {\n                                config.emitter.off('change', listener);\n                                resolve();\n                            }\n                        };\n                        config.emitter.on('change', listener);\n                    }),\n                    provider.request({\n                        method: 'wallet_switchEthereumChain',\n                        params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId) }],\n                    }),\n                ]);\n                const requestedChains = await this.getRequestedChainsIds();\n                this.setRequestedChainsIds([...requestedChains, chainId]);\n                return chain;\n            }\n            catch (err) {\n                const error = err;\n                if (/(user rejected)/i.test(error.message))\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                // Indicates chain is not added to provider\n                try {\n                    let blockExplorerUrls;\n                    if (addEthereumChainParameter?.blockExplorerUrls)\n                        blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                    else\n                        blockExplorerUrls = chain.blockExplorers?.default.url\n                            ? [chain.blockExplorers?.default.url]\n                            : [];\n                    let rpcUrls;\n                    if (addEthereumChainParameter?.rpcUrls?.length)\n                        rpcUrls = addEthereumChainParameter.rpcUrls;\n                    else\n                        rpcUrls = [...chain.rpcUrls.default.http];\n                    const addEthereumChain = {\n                        blockExplorerUrls,\n                        chainId: (0,viem__WEBPACK_IMPORTED_MODULE_1__.numberToHex)(chainId),\n                        chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                        iconUrls: addEthereumChainParameter?.iconUrls,\n                        nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n                        rpcUrls,\n                    };\n                    await provider.request({\n                        method: 'wallet_addEthereumChain',\n                        params: [addEthereumChain],\n                    });\n                    const requestedChains = await this.getRequestedChainsIds();\n                    this.setRequestedChainsIds([...requestedChains, chainId]);\n                    return chain;\n                }\n                catch (error) {\n                    throw new viem__WEBPACK_IMPORTED_MODULE_1__.UserRejectedRequestError(error);\n                }\n            }\n        },\n        onAccountsChanged(accounts) {\n            if (accounts.length === 0)\n                this.onDisconnect();\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onConnect(connectInfo) {\n            const chainId = Number(connectInfo.chainId);\n            const accounts = await this.getAccounts();\n            config.emitter.emit('connect', { accounts, chainId });\n        },\n        async onDisconnect(_error) {\n            this.setRequestedChainsIds([]);\n            config.emitter.emit('disconnect');\n            const provider = await this.getProvider();\n            if (accountsChanged) {\n                provider.removeListener('accountsChanged', accountsChanged);\n                accountsChanged = undefined;\n            }\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            if (sessionDelete) {\n                provider.removeListener('session_delete', sessionDelete);\n                sessionDelete = undefined;\n            }\n            if (!connect) {\n                connect = this.onConnect.bind(this);\n                provider.on('connect', connect);\n            }\n        },\n        onDisplayUri(uri) {\n            config.emitter.emit('message', { type: 'display_uri', data: uri });\n        },\n        onSessionDelete() {\n            this.onDisconnect();\n        },\n        getNamespaceChainsIds() {\n            if (!provider_)\n                return [];\n            const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map((account) => Number.parseInt(account.split(':')[1] || '', 10));\n            return chainIds ?? [];\n        },\n        async getRequestedChainsIds() {\n            return ((await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []);\n        },\n        /**\n         * Checks if the target chains match the chains that were\n         * initially requested by the connector for the WalletConnect session.\n         * If there is a mismatch, this means that the chains on the connector\n         * are considered stale, and need to be revalidated at a later point (via\n         * connection).\n         *\n         * There may be a scenario where a dapp adds a chain to the\n         * connector later on, however, this chain will not have been approved or rejected\n         * by the wallet. In this case, the chain is considered stale.\n         */\n        async isChainsStale() {\n            if (!isNewChainsStale)\n                return false;\n            const connectorChains = config.chains.map((x) => x.id);\n            const namespaceChains = this.getNamespaceChainsIds();\n            if (namespaceChains.length &&\n                !namespaceChains.some((id) => connectorChains.includes(id)))\n                return false;\n            const requestedChains = await this.getRequestedChainsIds();\n            return !connectorChains.every((id) => requestedChains.includes(id));\n        },\n        async setRequestedChainsIds(chains) {\n            await config.storage?.setItem(this.requestedChainsStorageKey, chains);\n        },\n        get requestedChainsStorageKey() {\n            return `${this.id}.requestedChains`;\n        },\n    }));\n}\n//# sourceMappingURL=walletConnect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3dhZ21pL25vZGVfbW9kdWxlcy9Ad2FnbWkvY29ubmVjdG9ycy9kaXN0L2VzbS93YWxsZXRDb25uZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErRztBQUNuQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLHFDQUFxQyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdEQUFVO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFLDJDQUEyQywwREFBd0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0RBQWdELGdEQUFVO0FBQzFELFNBQVM7QUFDVCw0QkFBNEIsVUFBVSxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQixRQUFRLHVRQUEwQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkRBQWM7QUFDcEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQSwwQkFBMEIsOERBQXFCO0FBQy9DO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWdCLEtBQUssZ0VBQXVCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUyxpREFBVyxXQUFXO0FBQ2xFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBEQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQXdCO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnREFBVTtBQUM1RCxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy93YWdtaS9ub2RlX21vZHVsZXMvQHdhZ21pL2Nvbm5lY3RvcnMvZGlzdC9lc20vd2FsbGV0Q29ubmVjdC5qcz8wMzVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYWluTm90Q29uZmlndXJlZEVycm9yLCBjcmVhdGVDb25uZWN0b3IsIGV4dHJhY3RScGNVcmxzLCBQcm92aWRlck5vdEZvdW5kRXJyb3IsIH0gZnJvbSAnQHdhZ21pL2NvcmUnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgbnVtYmVyVG9IZXgsIFN3aXRjaENoYWluRXJyb3IsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgfSBmcm9tICd2aWVtJztcbndhbGxldENvbm5lY3QudHlwZSA9ICd3YWxsZXRDb25uZWN0Jztcbi8qKlxuICogQGRlcHJlY2F0ZWQgKipOT1RFOiBUaGlzIGNvbm5lY3RvciB1c2VzIGEgdnVsbmVyYWJsZSBkZXBlbmRlbmN5IGRvd25zdHJlYW0qKiAoYEB3YWxsZXRjb25uZWN0L2V0aGVyZXVtLXByb3ZpZGVyQDIuMjEuMWAgPiBgQHJlb3duL2FwcGtpdEAxLjguOWAgPiBgQHJlb3duL2FwcGtpdC11dGlsc0AxLjguOWAgPiBgQHdhbGxldGNvbm5lY3QvbG9nZ2VyQDIuMS4yYCA+IGBwaW5vQDcuMTEuMGApLiBZb3Ugc2hvdWxkIG92ZXJyaWRlIGBwaW5vYCB0byBhIHNlY3VyZSB2ZXJzaW9uIHZpYSB5b3VyIHBhY2thZ2UgbWFuYWdlcjpcbiAqXG4gKiAjIyMgbnBtXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwib3ZlcnJpZGVzXCI6IHtcbiAqICAgICBcIkB3YWxsZXRjb25uZWN0L2xvZ2dlclwiOiB7XG4gKiAgICAgICBcInBpbm9cIjogXCIxMC4wLjBcIlxuICogICAgIH1cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMjIHBucG1cbiAqIGBgYGpzb25cbiAqIHtcbiAqICAgXCJwbnBtXCI6IHtcbiAqICAgICBcIm92ZXJyaWRlc1wiOiB7XG4gKiAgICAgICBcIkB3YWxsZXRjb25uZWN0L2xvZ2dlcj5waW5vXCI6IFwiMTAuMC4wXCJcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyB5YXJuXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwicmVzb2x1dGlvbnNcIjoge1xuICogICAgIFwiQHdhbGxldGNvbm5lY3QvbG9nZ2VyL3Bpbm9cIjogXCIxMC4wLjBcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgYnVuXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwib3ZlcnJpZGVzXCI6IHtcbiAqICAgICBcIkB3YWxsZXRjb25uZWN0L2xvZ2dlclwiOiB7XG4gKiAgICAgICBcInBpbm9cIjogXCIxMC4wLjBcIlxuICogICAgIH1cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogTm9ybWFsbHkgdGhlIFdhZ21pIHRlYW0gd291bGQgdXBncmFkZSBgQHdhbGxldGNvbm5lY3QvZXRoZXJldW0tcHJvdmlkZXJgIHRvIGEgZml4ZWQgdmVyc2lvbiBmb3IgeW91LCBidXQgYEB3YWxsZXRjb25uZWN0L2V0aGVyZXVtLXByb3ZpZGVyYCB3YXMgcmVsaWNlbnNlZCByZWNlbnRseSBmcm9tIEFwYWNoZSB0byBhIFtub24tcGVybWlzc2l2ZSBsaWNlbnNlXShodHRwczovL2dpdGh1Yi5jb20vcmVvd24tY29tL2FwcGtpdC9ibG9iL21haW4vTElDRU5TRS5tZCkuIFdlIGFyZSB0cnlpbmcgdG8gZ2V0IHRoZSBXYWxsZXRDb25uZWN0IHRlYW0gdG8gcmVsZWFzZSBhIHZlcnNpb24gdGhhdCBjbG9zZXMgdGhlIHZ1bG5lcmFiaWxpdHkgdW5kZXIgdGhlIG9sZCBBcGFjaGUgbGljZW5zZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhbGxldENvbm5lY3QocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzTmV3Q2hhaW5zU3RhbGUgPSBwYXJhbWV0ZXJzLmlzTmV3Q2hhaW5zU3RhbGUgPz8gdHJ1ZTtcbiAgICBsZXQgcHJvdmlkZXJfO1xuICAgIGxldCBwcm92aWRlclByb21pc2U7XG4gICAgY29uc3QgTkFNRVNQQUNFID0gJ2VpcDE1NSc7XG4gICAgbGV0IGFjY291bnRzQ2hhbmdlZDtcbiAgICBsZXQgY2hhaW5DaGFuZ2VkO1xuICAgIGxldCBjb25uZWN0O1xuICAgIGxldCBkaXNwbGF5VXJpO1xuICAgIGxldCBzZXNzaW9uRGVsZXRlO1xuICAgIGxldCBkaXNjb25uZWN0O1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3IoKGNvbmZpZykgPT4gKHtcbiAgICAgICAgaWQ6ICd3YWxsZXRDb25uZWN0JyxcbiAgICAgICAgbmFtZTogJ1dhbGxldENvbm5lY3QnLFxuICAgICAgICB0eXBlOiB3YWxsZXRDb25uZWN0LnR5cGUsXG4gICAgICAgIGFzeW5jIHNldHVwKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlc3Npb25EZWxldGUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uRGVsZXRlID0gdGhpcy5vblNlc3Npb25EZWxldGUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5vbignc2Vzc2lvbl9kZWxldGUnLCBzZXNzaW9uRGVsZXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY29ubmVjdCh7IGNoYWluSWQsIHdpdGhDYXBhYmlsaXRpZXMsIC4uLnJlc3QgfSA9IHt9KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVVyaSA9IHRoaXMub25EaXNwbGF5VXJpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzcGxheV91cmknLCBkaXNwbGF5VXJpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldENoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0Q2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IChhd2FpdCBjb25maWcuc3RvcmFnZT8uZ2V0SXRlbSgnc3RhdGUnKSkgPz8ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hhaW5TdXBwb3J0ZWQgPSBjb25maWcuY2hhaW5zLnNvbWUoKHgpID0+IHguaWQgPT09IHN0YXRlLmNoYWluSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDaGFpblN1cHBvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENoYWluSWQgPSBzdGF0ZS5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDaGFpbklkID0gY29uZmlnLmNoYWluc1swXT8uaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0Q2hhaW5JZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbnMgZm91bmQgb24gY29ubmVjdG9yLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hhaW5zU3RhbGUgPSBhd2FpdCB0aGlzLmlzQ2hhaW5zU3RhbGUoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBhY3RpdmUgc2Vzc2lvbiB3aXRoIHN0YWxlIGNoYWlucywgZGlzY29ubmVjdCBjdXJyZW50IHNlc3Npb24uXG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnNlc3Npb24gJiYgaXNDaGFpbnNTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzbid0IGFuIGFjdGl2ZSBzZXNzaW9uIG9yIGNoYWlucyBhcmUgc3RhbGUsIGNvbm5lY3QuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlci5zZXNzaW9uIHx8IGlzQ2hhaW5zU3RhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uYWxDaGFpbnMgPSBjb25maWcuY2hhaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChjaGFpbikgPT4gY2hhaW4uaWQgIT09IHRhcmdldENoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChvcHRpb25hbENoYWluKSA9PiBvcHRpb25hbENoYWluLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbENoYWluczogW3RhcmdldENoYWluSWQsIC4uLm9wdGlvbmFsQ2hhaW5zXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLigncGFpcmluZ1RvcGljJyBpbiByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHBhaXJpbmdUb3BpYzogcmVzdC5wYWlyaW5nVG9waWMgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1ZXN0ZWRDaGFpbnNJZHMoY29uZmlnLmNoYWlucy5tYXAoKHgpID0+IHguaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgc2Vzc2lvbiBleGlzdHMgYW5kIGNoYWlucyBhcmUgYXV0aG9yaXplZCwgZW5hYmxlIHByb3ZpZGVyIGZvciByZXF1aXJlZCBjaGFpblxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IHByb3ZpZGVyLmVuYWJsZSgpKS5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCB0byBjaGFpbiBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbklkICYmIGN1cnJlbnRDaGFpbklkICE9PSBjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluID0gYXdhaXQgdGhpcy5zd2l0Y2hDaGFpbih7IGNoYWluSWQgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYXVzZT8ubWVzc2FnZSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01pc3Npbmcgb3IgaW52YWxpZC4gcmVxdWVzdCgpIG1ldGhvZDogd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGN1cnJlbnRDaGFpbklkIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW5JZCA9IGNoYWluPy5pZCA/PyBjdXJyZW50Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Rpc3BsYXlfdXJpJywgZGlzcGxheVVyaSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlVcmkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHRoaXMub25DaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZWxldGUgPSB0aGlzLm9uU2Vzc2lvbkRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignc2Vzc2lvbl9kZWxldGUnLCBzZXNzaW9uRGVsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHM6ICh3aXRoQ2FwYWJpbGl0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gKHsgYWRkcmVzcywgY2FwYWJpbGl0aWVzOiB7fSB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYWNjb3VudHMpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKC8odXNlciByZWplY3RlZHxjb25uZWN0aW9uIHJlcXVlc3QgcmVzZXQpL2kudGVzdChlcnJvcj8ubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9ObyBtYXRjaGluZyBrZXkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI/LnJlbW92ZUxpc3RlbmVyKCdjaGFpbkNoYW5nZWQnLCBjaGFpbkNoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyPy5yZW1vdmVMaXN0ZW5lcignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHRoaXMub25Db25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyPy5vbignY29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyPy5yZW1vdmVMaXN0ZW5lcignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNDaGFuZ2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkRlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcj8ucmVtb3ZlTGlzdGVuZXIoJ3Nlc3Npb25fZGVsZXRlJywgc2Vzc2lvbkRlbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZWxldGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWVzdGVkQ2hhaW5zSWRzKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5hY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRQcm92aWRlcih7IGNoYWluSWQgfSA9IHt9KSB7XG4gICAgICAgICAgICBhc3luYyBmdW5jdGlvbiBpbml0UHJvdmlkZXIoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uYWxDaGFpbnMgPSBjb25maWcuY2hhaW5zLm1hcCgoeCkgPT4geC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25hbENoYWlucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IEV0aGVyZXVtUHJvdmlkZXIgfSA9IGF3YWl0IGltcG9ydCgnQHdhbGxldGNvbm5lY3QvZXRoZXJldW0tcHJvdmlkZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgRXRoZXJldW1Qcm92aWRlci5pbml0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVByb3ZpZGVyUGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxDaGFpbnMsXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogcGFyYW1ldGVycy5wcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgICAgIHJwY01hcDogT2JqZWN0LmZyb21FbnRyaWVzKGNvbmZpZy5jaGFpbnMubWFwKChjaGFpbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3VybF0gPSBleHRyYWN0UnBjVXJscyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0czogY29uZmlnLnRyYW5zcG9ydHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY2hhaW4uaWQsIHVybF07XG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1FyTW9kYWw6IHBhcmFtZXRlcnMuc2hvd1FyTW9kYWwgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJvdmlkZXJfKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlclByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyUHJvbWlzZSA9IGluaXRQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyXyA9IGF3YWl0IHByb3ZpZGVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl8/LmV2ZW50cy5zZXRNYXhMaXN0ZW5lcnMoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbklkKVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3dpdGNoQ2hhaW4/Lih7IGNoYWluSWQgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJfO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuY2hhaW5JZDtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgaXNBdXRob3JpemVkKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYWNjb3VudHMsIHByb3ZpZGVyXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRBY2NvdW50cygpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFByb3ZpZGVyKCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgc2Vzc2lvbiwgdGhlbiB0aGUgY29ubmVjdG9yIGlzIHVuYXV0aG9yaXplZC5cbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGFpbnMgYXJlIHN0YWxlIG9uIHRoZSBzZXNzaW9uLCB0aGVuIHRoZSBjb25uZWN0b3IgaXMgdW5hdXRob3JpemVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hhaW5zU3RhbGUgPSBhd2FpdCB0aGlzLmlzQ2hhaW5zU3RhbGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFpbnNTdGFsZSAmJiBwcm92aWRlci5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLmRpc2Nvbm5lY3QoKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc3dpdGNoQ2hhaW4oeyBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLCBjaGFpbklkIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RGb3VuZEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNvbmZpZy5jaGFpbnMuZmluZCgoeCkgPT4geC5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhaW5JZCA9PT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5vZmYoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5vbignY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluSWQpIH1dLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRDaGFpbnMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENoYWluc0lkcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWVzdGVkQ2hhaW5zSWRzKFsuLi5yZXF1ZXN0ZWRDaGFpbnMsIGNoYWluSWRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKC8odXNlciByZWplY3RlZCkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgY2hhaW4gaXMgbm90IGFkZGVkIHRvIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrRXhwbG9yZXJVcmxzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8uYmxvY2tFeHBsb3JlclVybHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyA9IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIuYmxvY2tFeHBsb3JlclVybHM7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzID0gY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBycGNVcmxzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ucnBjVXJscz8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyA9IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXIucnBjVXJscztcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyA9IFsuLi5jaGFpbi5ycGNVcmxzLmRlZmF1bHQuaHR0cF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZEV0aGVyZXVtQ2hhaW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5jaGFpbk5hbWUgPz8gY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25VcmxzOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5pY29uVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5uYXRpdmVDdXJyZW5jeSA/PyBjaGFpbi5uYXRpdmVDdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbYWRkRXRoZXJldW1DaGFpbl0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRDaGFpbnMgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENoYWluc0lkcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJlcXVlc3RlZENoYWluc0lkcyhbLi4ucmVxdWVzdGVkQ2hhaW5zLCBjaGFpbklkXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25BY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYWluQ2hhbmdlZChjaGFpbikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihjaGFpbik7XG4gICAgICAgICAgICBjb25maWcuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7IGNoYWluSWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uQ29ubmVjdChjb25uZWN0SW5mbykge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihjb25uZWN0SW5mby5jaGFpbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY29ubmVjdCcsIHsgYWNjb3VudHMsIGNoYWluSWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdChfZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVxdWVzdGVkQ2hhaW5zSWRzKFtdKTtcbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXNzaW9uRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ3Nlc3Npb25fZGVsZXRlJywgc2Vzc2lvbkRlbGV0ZSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbkRlbGV0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRGlzcGxheVVyaSh1cmkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ21lc3NhZ2UnLCB7IHR5cGU6ICdkaXNwbGF5X3VyaScsIGRhdGE6IHVyaSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TZXNzaW9uRGVsZXRlKCkge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmFtZXNwYWNlQ2hhaW5zSWRzKCkge1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlcl8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZHMgPSBwcm92aWRlcl8uc2Vzc2lvbj8ubmFtZXNwYWNlc1tOQU1FU1BBQ0VdPy5hY2NvdW50cz8ubWFwKChhY2NvdW50KSA9PiBOdW1iZXIucGFyc2VJbnQoYWNjb3VudC5zcGxpdCgnOicpWzFdIHx8ICcnLCAxMCkpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluSWRzID8/IFtdO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRSZXF1ZXN0ZWRDaGFpbnNJZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gKChhd2FpdCBjb25maWcuc3RvcmFnZT8uZ2V0SXRlbSh0aGlzLnJlcXVlc3RlZENoYWluc1N0b3JhZ2VLZXkpKSA/PyBbXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHRhcmdldCBjaGFpbnMgbWF0Y2ggdGhlIGNoYWlucyB0aGF0IHdlcmVcbiAgICAgICAgICogaW5pdGlhbGx5IHJlcXVlc3RlZCBieSB0aGUgY29ubmVjdG9yIGZvciB0aGUgV2FsbGV0Q29ubmVjdCBzZXNzaW9uLlxuICAgICAgICAgKiBJZiB0aGVyZSBpcyBhIG1pc21hdGNoLCB0aGlzIG1lYW5zIHRoYXQgdGhlIGNoYWlucyBvbiB0aGUgY29ubmVjdG9yXG4gICAgICAgICAqIGFyZSBjb25zaWRlcmVkIHN0YWxlLCBhbmQgbmVlZCB0byBiZSByZXZhbGlkYXRlZCBhdCBhIGxhdGVyIHBvaW50ICh2aWFcbiAgICAgICAgICogY29ubmVjdGlvbikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXJlIG1heSBiZSBhIHNjZW5hcmlvIHdoZXJlIGEgZGFwcCBhZGRzIGEgY2hhaW4gdG8gdGhlXG4gICAgICAgICAqIGNvbm5lY3RvciBsYXRlciBvbiwgaG93ZXZlciwgdGhpcyBjaGFpbiB3aWxsIG5vdCBoYXZlIGJlZW4gYXBwcm92ZWQgb3IgcmVqZWN0ZWRcbiAgICAgICAgICogYnkgdGhlIHdhbGxldC4gSW4gdGhpcyBjYXNlLCB0aGUgY2hhaW4gaXMgY29uc2lkZXJlZCBzdGFsZS5cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGlzQ2hhaW5zU3RhbGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmV3Q2hhaW5zU3RhbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdG9yQ2hhaW5zID0gY29uZmlnLmNoYWlucy5tYXAoKHgpID0+IHguaWQpO1xuICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlQ2hhaW5zID0gdGhpcy5nZXROYW1lc3BhY2VDaGFpbnNJZHMoKTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VDaGFpbnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgIW5hbWVzcGFjZUNoYWlucy5zb21lKChpZCkgPT4gY29ubmVjdG9yQ2hhaW5zLmluY2x1ZGVzKGlkKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkQ2hhaW5zID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0ZWRDaGFpbnNJZHMoKTtcbiAgICAgICAgICAgIHJldHVybiAhY29ubmVjdG9yQ2hhaW5zLmV2ZXJ5KChpZCkgPT4gcmVxdWVzdGVkQ2hhaW5zLmluY2x1ZGVzKGlkKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHNldFJlcXVlc3RlZENoYWluc0lkcyhjaGFpbnMpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbmZpZy5zdG9yYWdlPy5zZXRJdGVtKHRoaXMucmVxdWVzdGVkQ2hhaW5zU3RvcmFnZUtleSwgY2hhaW5zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHJlcXVlc3RlZENoYWluc1N0b3JhZ2VLZXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5pZH0ucmVxdWVzdGVkQ2hhaW5zYDtcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXRDb25uZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/wagmi/node_modules/@wagmi/connectors/dist/esm/walletConnect.js\n"));

/***/ })

}]);